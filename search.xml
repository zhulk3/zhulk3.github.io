<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>校友会小记</title>
      <link href="/2025/05/24/%E6%A0%A1%E5%8F%8B%E4%BC%9A%E5%B0%8F%E8%AE%B0/"/>
      <url>/2025/05/24/%E6%A0%A1%E5%8F%8B%E4%BC%9A%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>今天参加了中山大学北京校友会举办的青年校友策划交流会，此前的几次都没有去，觉得活动很官方，估计没有什么干货。最近一段时间学一些课程，课程中都强调要与人，特别是同行或者校友建立连接，这也许会成为我们职业发展的助力。另一个原因是最近有计划将工作内容与大模型相关的工作结合起来，但是没想清楚如何切入，看看能不能有合适的校友可以一起讨论一下。</p><p>校友自我介绍到一半，因为缨宁学姐中途有事需要离开，她提前开始了分享环节。她很优秀，在校期间一直拿过奖、毕业拿到过Google的offer、一度达到了阿里P10的职级、辞职创业等，这一路开挂的人生，让人既羡慕又崇拜。不过多去说这些优秀，她那些独特的个人品质才应该是我们晚辈更应该关注和学习的。QA环节提到一个问题是什么勇气使得她能离开大厂开启创业，她的答案是钝感力的原因。不去过多的计算收入，而应该向内看，自己人生追求的目标是什么，如果是钱，那永远都是在玩别人设计好的游戏。只有建立自己内心的标尺，选择自己喜欢的工作，才能持续投入精力去把工作做好，才能做到不内耗不抗拒。自己在互联网工作快四年了，尚处于在别人设计的评价框架里面工作，还在为了晋升规则做很多不是那么喜欢的事情，但是从长远来看，确实要不断思考自己喜欢什么，不喜欢什么，选择自己喜欢的事情才能有源源不断的内驱力。另一个问题是如何形成稳定的内核，她的回答是尽可能多的尝试，多碰壁，多迭代，现实世界会不断给你反馈，在不断的和世界交互的过程中，我们才能逐渐形成自己的观念。这个回答也让我受教了，之前的自己有自己的一套行为规范和处事原则，从来没有反问过自己，这些原则是否就是正确的，是一种没有主动和外界碰撞，主动进化的状态。听到她的回答后，感觉以后应该主动的去改变一些自己的行为，不断的提问自己，现在的一些想法和做法是否正确，多对比、多改进、多进步。</p><p>另一位在外企工作多年的学姐，璇姐，也做了一些分享，记录了一些在以后工作和生活中也应该付诸实践的好点子。</p><ul><li>卷还是躺平，选择哪条路都可以，但是选择了以后就不要纠结。诚然，现实中不可能同时去走两条路，然后再去对比哪条路更好。当下想清楚以后，就坚定走下去，不要既要又要。</li><li>有意义的卷，勤奋是一种美德。这个点也引起我的共鸣了，我是主张积极努力的，我们可以努力做好工作，可以努力提升自己的软硬能力，可以努力让自己和家人过上更好的生活，这些都没有问题，但是不要花时间去做一些无意义的事情，比如躺在工位上熬加班时长，一个文档PPT疯狂去过度设计动效之类的。另外一点，现在很多人分不清楚内卷和努力的区别，怕别人觉得自己努力就是占到了别人的对立面，怕别人认为自己卷，认为自己不合群。这种想法不可取，努力就光明正大的努力，努力只要能产生正向的收益，就值得努力，内卷是无意义的做一些事情，和勤奋是不同的，应该有勇敢的勤奋。</li><li>对于职场贵人，应该努力链接，积极贡献。说起职场贵人，我觉得我是遇到过一位的，他换团队时带着我换了团队，给我出差学习机会，好的绩效等，但是因为我对这个工作方向不感兴趣离开了他的团队，临走时也感觉很真心的有在挽留我。当然，再重新选择一次我肯定还是会选择自己感兴趣的工作方向，但是做事方式方法上有很多值得改正的地方，比如总觉得对不起他，然后离开以后就没有再联络了，其实可以换一些沟通方式，也许以后还有合作的机会。对于璇姐的话，另一个理解就是主动去认识贵人，而不是被动的等着被发现，在工作中认真负责，建立起和老板之间的信任，可以加大老板成为你贵人的可能，毕竟职场是互利的，老板也需要工作能力过硬的人帮他cover住一个方向的业务，在业务起火时你能起到灭火的作用。</li><li>建立职场人设，保持积极，打磨技能，终身学习。这一点又引起我的共鸣了，上一份工作，和老板最后处得不是很和谐，绩效不好，后来老板透露说绩效不好的另一个原因是同事互评绩效环节，同事们给的评价也不高。同事们给的评价很多时候来源于你在团队内部的活跃程度，比如做一些技术分享，帮助解决业务难题之类的，要在这些环节秀出来，多刷脸，而不是关注自己的一亩三分地，对团队影响力这些完全不关注。一个积极靠谱的人设需要长期维护，对职业发展也会有很大的益处。</li></ul><p>莹姐也做了很多分享，印象最深的就是她提到了意愿优先于能力这个观点。我们选择合作伙伴如此，我们对自己的要求也同样如此，我们可以暂时不会什么，这个不是特别重要，只要我们有坚定的能学会这个技能，做好这件事的决心，就已经成功了一大半了。我们面临的大多数事情，都没有特别难，只要原因花时间，愿意去找方法，肯定都能做成。比如我自己毕业时选择是做Android开发的，但是工作一段时间后更倾向于Java web开发，就花了很多时间去自学、去转岗，不去考虑什么沉没成本，坚定的去做，现在也转型成功一年多了，边工作边补课，逐渐也适应了。相反，其他一些同事觉得很难，没有坚定转型的，现在工作机会越来越少，换工作都没有太多选择。</p><p>还有很多优秀的同学，虽然没有深入交流，但是她们表达清晰，逻辑顺畅，有规划，有思考，感觉又回到了大学校园里高手环绕的状态。总的来说，今天的交流会不虚此行，取其精华，今后继续积极向上。</p>]]></content>
      
      
      <categories>
          
          <category> 2025 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>往者不可谏，来者犹可追</title>
      <link href="/2025/01/01/review-2024/"/>
      <url>/2025/01/01/review-2024/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>2024年的时间是被繁重的工作填满的一年，很多年初计划好的事情，因为忙碌的工作搞得身心俱疲，没有精力去做。这两天在回顾过去这一年有什么成长，收获了什么，失去了什么，最大的感触就是工作已经占据了我绝大部分的时间和注意力，导致现在往回看的时候，对这一年是过得不太满意的，因为在工作的驱使压迫下，失去了自己的节奏，没有把时间合理的分配到自己想做的事情上。因为收获不多，对于盘点这一年的得与失是有点回避心理的，但是每年例行的习惯，还是想做一下这件事，仔细回看一下，这一年时间都去哪里了，踏浪莫忘回首嘛。</p><p>工作仍然是主旋律，从毕业开始就一直挺不喜欢做移动端开发的，多数的时间都在调整UI和处理各种恶心的机型适配，常常感觉没有技术含量和前途。在今年三月，通过公司内部转岗，开始做后端开发。业务逻辑确实比移动端更加复杂，工作量变多，加上自己不熟悉工作，导致一整年都在加班。在工作上花了很多时间，也踩了很多坑，经验教训都不少，需要好好想想，吃一堑长一智。</p><p><img src="http://images.zhulk3.cn/blog/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%932024/WechatIMG59.jpeg"></p><p>今年考到了摩托车证。从去年开始报名，在今年七月拿到了证件，距离摩旅G219又近了一步。长期的在无聊的工作中消耗生命，就越发的想要去无人的荒野上驰骋。对于摩旅这件事既想冲动的出发，让生命变得更有意义，又不断在要不要裸辞的想法中挣扎，身处在现实社会中，就要考虑就业和生活问题。处在一种很隔离的状态，心里想鲜衣怒马流浪天涯，实际是做牛做马一天不落。最后要不要决定出发，就要看自己更想要的是什么了，总不能做什么都是既要要又要的心态。</p><p><img src="http://images.zhulk3.cn/blog/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%932024/WechatIMG60.jpeg"></p><p>存钱，目前看达到了年初的既定目标，实现了100+个的目标，这个没有什么悬念，就是靠工资，然后不乱花就行。对于花钱的观点，秉持着合理控制自己消费欲望，对家人尽量大方的原则，做到不乱花钱，但是也不用刻意节约，这种方式刚好够满足自己的要求。感觉目前工作没有什么热情，没有主动投入思考的欲望，也就不算喜欢，这不是长久之计，没办法一直做自己不喜欢的工作。未来可能希望做一些轻松一点、有主动投入精力的欲望的工作，能有更多的时间做自己喜欢做的事情，这也需要提前存一些钱准备一下物质基础。</p><p>2024年也出门旅游了几次，总体的感觉就是，不同的城市会有一点自己的特色，但是好像所有的城市都在趋同。一月去了上海和苏州，上海的特色就是现代，苏州还保有很多白墙灰瓦的建筑，但是商业化也很严重。三月去了重庆，对重庆的印象是很辣很辣的火锅，四月去了武汉，对武汉的肥肥虾印象很好，下次还想吃。九月去了吉林，看了长白山，很惊艳，觉得不虚此行。</p><p><img src="http://images.zhulk3.cn/blog/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%932024/WechatIMG53.jpeg"></p><p>今年开始把有计划的进行技术博客的写作，一方面是为了补课，另一方面是为了平时有目的性的积累，方便面试的时候体现出个人对专业的热爱和投入，建立人设。整体上来说，也没用达成年初设定的目标，预期是十篇，从数量上来说只有七篇，另一方面是在写作质量上，都是学习性的笔记类型，缺乏从工作实践中积累的主题，有点泛泛而谈的感觉。</p><p><img src="http://images.zhulk3.cn/blog/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%932024/WechatIMG61.png"></p><p>今年也有继续在抽时间阅读和专业无关的书籍，《基金投资》、《有钱人和你想的不一样》、《置身事内》、《黑天鹅》、《时间简史》、《人类简史》和《未来简史》。每次读完一本书其实能够记下来的并不多，有时候甚至花几周读完的一本书，也大概只能记下来几个章节的主旨大意或者一两段话，其实这样也就够了，这一两句话至少唤起了我们的一些共鸣，让我们更清晰的认同了我们已有的一些想法，或者告诉了我们一些简单的道理。比如，读《黑天鹅》时，对下面这句话狠狠的赞同了：</p><p><em>想象一个10亿倍于地球的行星边缘上的一粒尘埃。这粒尘埃就代表你出生的概率，庞大的行星则代表相反的概率。所以不要再为小事烦恼了。不要再像一个忘恩负义者，得到一座城堡，还要介意浴室里的霉菌。不要再检查别人赠予你的马匹的牙齿，请记住，你就是黑天鹅。</em></p><p>每年都希望有计划的投入足够多的时间去锻炼身体，也一直坚持在做这件事，但是今年这件事是做得最差的。年初还能坚持一段时间，打羽毛球、跑步或者健身，后来渐渐的空闲时间都被工作挤满，有点空闲也只想躺着了。锻炼身体的益处有很多，一方面是长期的健康，另一方面是压力的宣泄，每次跑完半小时，感觉整个身体都轻盈了许多。来年希望在坚持锻炼这件事上可以做得更好。时间的惯性是巨大的，长期坚持做一件事其实并不会感觉很累，同样的，躺在床上休息两天也不会感觉有多放松，锻炼身体不会是一朝一夕的事情，需要把量均匀的分散在每一天中，慢慢坚持，慢慢从中获益。</p><p>2025又是新的一年，老规矩，想了一些要做的事情：</p><ul><li>坚持务实主义，换一份工作，实现一定程度的涨薪；</li><li>坚持专业学习，专注在常用组件和框架、工作方法、架构设计等方向，输出技术博客十篇；</li><li>坚持锻炼身体，一小时锻炼量超过100次，体重减到130斤以下；</li><li>坚持阅读，主题在传记、通用能力等方向，阅读量超过10本；</li><li>学习吉他，能够熟练演奏五首歌曲；</li><li>买一辆自己的摩托，并能够熟练驾驶，为摩旅做准备；</li><li>在副业方向做一些探索，实现除了工资之外有其他收入来源；</li><li>考系统架构设计师（高级）、PMP项目管理师、系统分析师；</li></ul><p>2025年，保持全力以赴的态度。</p><p><img src="http://images.zhulk3.cn/blog/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%932024/WechatIMG57.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> 年度总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今日简史</title>
      <link href="/2024/04/04/%E4%BB%8A%E6%97%A5%E7%AE%80%E5%8F%B2/"/>
      <url>/2024/04/04/%E4%BB%8A%E6%97%A5%E7%AE%80%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>科技在进步，人类就能生活得更好吗？客观来说，科学技术是提高生产力的有效手段，举个例子，在古代，通过牛耕地，现在机械化和大棚种植，生产效率肯定是提高了的；相比通过书信传递信息的时代，现在可以随时随地联系好友；现在的飞机、高铁也比古代的马车快了很多倍。但是，人类有因为科学技术进步而变得更轻松，更幸福吗？这个问题没有办法直接说是变得幸福了或者变得痛苦了，每个人都有不同的看法，甚至一个人不同时期也有不同的看法。人口预期寿命、婴儿死亡率等不可否认的随着医疗条件提高得到了改善，改良作物和机械化种植使得粮食产量、种类大幅提升，人们却是吃得更好了，这些都是科技进步的好处。但是，科技发展也带来了很多问题，环境污染，气候变暖等，动物灭绝速度加快等，都在影响人类的生存。核威胁，就像悬在全人类头上的一把剑，如果持有核武器的国家失控，引发战争，顷刻之间，成百上千的人就会失去生命。对个人而言，好像由于科技的进步人们变得越来约忙碌，越来越孤单了，通讯设备让人们随时随地在工作，便捷的交通工具加速了人们的迁徙，与社群的联系越来越弱。人们在不断发展科技的同时，需要好好想一下，怎么运用科技来造福人类也很重要。</p><p>大数据时对我们的生活都有哪些影响？当代社会，人们已经离不开互联网了。使用网络购物、社交、解决衣食住行的各种问题。这就导致我们大量的私人信息保留在了这些服务提供者的服务器里面，通过这些数据，分析我们的习惯、爱好等，再给我们推荐各种他们希望我们看到的东西。长此以往，第一个问题就是信息茧房，算法通过分析我们的习惯，越来约精准的推荐我们感兴趣的东西，看到的也只是我们感兴趣的，对这个世界的了解的渠道逐渐变得单一，这是很危险的，我们每个人的对世界的了解变得片面，产生偏见等，和其他人的交往、共情都将变得困难，主动获取信息，过滤掉不必要的信息将会非常重要。另一个问题是隐私问题，我们那么多私人数据，由服务提供商保存，他们能确保数据安全并且不作他用吗？没有人能够保证，时常收到各种骚扰信息是小问题，个人隐私信息泄漏导致甚至可能导致诈骗和人身安全问题。</p><p>社会快速发展，教育怎么跟上步伐？在古代，中国学习四书五经，射箭弹琴，到了现代，学习内容虽然有了一些变化，但是教育模式等还是没有太大区别。但是这个社会的发展是越来越迅速的，我们会继续保持这种教育模式下去吗？未来机器人和人工智能的运用越来越普及，这是趋势，所以很多简单重复的工作都将被取代。又一个论调是，每次科技革命淘汰掉一些岗位，都会催生新的岗位。这个观点我认同，但是被淘汰掉的工人呢？可以进入到其他岗位吗？这很难说。因为未来的工作岗位一定是工作要求比较高的，不是有手就行，不能通过简单的培训就可以上岗的。办法也也许不止一个，但是重视未来的变化，拥抱变化，坚持学习对多数人才是根本办法。没有办法想象未来三十年是什么样子，需要哪些人才，哪些岗位又会被淘汰掉，但是人才要求一定是越来越高的，所以教育模式也得跟上科技发展。</p><p>战争和恐怖主义的一点理解。世界上的大国，每年都会投入巨额资金用于发展军事武器，很多高科技产品最开始都是由军事目的研发的，淘汰以后才是民用，所以现在最高端的武器都是在各个国家的军队里面。原子弹，氢弹已经诞生80多年了，这80年间不知道又研发了多少威力更大的武器，如果拥有核武器的国家在战争中使用核武器，顷刻之间，就会有无数人丧命。现在只能寄希望于各个国家是非常冷静的，不会随意使用，但是这种把人类安全交给人的理智来决定，还是多少让人感到不安。恐怖主义，每年因此丧命的人少之又少，但是为什么大家谈之色变呢？《今日简史》作者的观点是之前没有看到过的，发达恐怖主义袭击的人都是弱者，他们无法通过发动战争来获得他们希望的好处，所以通过发动小规模袭击，大肆宣传，让人们恐慌，只要政府恐慌，应付措施就会发生变形，恐怖主义者就有了可乘之机。政府应对恐怖主义袭击本来可以通过静悄悄的方式来打击，但是为了让民众知道自己在行动，就要大张旗鼓的行动，但大张旗鼓往往容易旁生枝节，正中恐怖主义者的下怀。</p>]]></content>
      
      
      <categories>
          
          <category> 2024 reading23 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>黑天鹅</title>
      <link href="/2024/04/04/%E9%BB%91%E5%A4%A9%E9%B9%85/"/>
      <url>/2024/04/04/%E9%BB%91%E5%A4%A9%E9%B9%85/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>《黑天鹅》这本书是2024年读完的第一本书，从2023年年底，看到2024年，可以说花了两年时间。今年年初立下Flag，每读完一本书，都写一点东西，保持输入的同时，也要保持输出。</p><p>在发现澳大利亚黑天鹅之前，所有的欧洲人都认为天鹅的羽毛都是白色的，当第一次发现黑天鹅时，人们关于天鹅羽毛颜色是白色的牢不可破的信念即被打破了，所以黑天鹅表示那些发生概率极低，但是影响巨大且深远的事件。</p><p>首先想抱怨一下，这本书真的让人感觉很冗长，一些表达很发散，但是在章节结尾没有回归到想要表达的思想上来，尤其是一些举例，给人无疾而终、戛然而止的感觉。部分章节数学计算也非必要，推导过程看得让人发昏。瑕不掩瑜，整体来看这本书还是很值得一读的，首先是核心思想就打破常规，提醒读者不要因为一些稀少事件发生概率低就选择无视，往往是这些事件的让历史或者个人人生发展轨迹发生大转弯，其次作者通过一些举例，反驳了一些概率理论，或者来自权威专家或者来自课本，是如何根深蒂固的影响着我们，但是被错误使用的。</p><p>选择了一些书中的观点，结合个人思考，说一下个人的理解。</p><p>历史从不爬行，只是跃迁。作者认为历史并不是平稳的发展的，把时间维度拉长来看，总是一些偶然事件，极大的推动了历史的发展。确实，这个观点我觉得是正确的。比如原始人因为偶然发现了一些种植谷类，逐渐从采集社会发展到种植定居社会、发现新大论和麦哲伦环球这样偶然的事件导致了黑奴贸易，殖民和现在的种族问题、一些偶然的科学发现极大的推动了生产力的提高等等。对于个人，关注这些需要很长时间才能显现影响力的宏观事件意义并不大，但是个人的人生轨迹应该也不是平稳向前的，也充斥着各种或好或坏的随机事件，我们应该以什么样的态度去看待人生的稳定和动荡呢？我认为，人生轨迹不是线性的，或者说没有什么发展规律是线性的，前进必然伴随着起起伏伏。拿职业发展来说，今天平平无奇的去上班然后顺利下班，不代表以后每一天都会这样，说不定在未来某一天会遇到职业的危机或者机遇，我们能做的，是掌控自己能掌控的部分，多主动一点，提升自己的能力、协调自己的发力方向和行业发展方向，做到同向而行。追求稳定断不可取，变化才是唯一不变的，如作者所说，不要做一只火鸡，前999天喂食的手，也可能在第1000天拧断它的脖颈。</p><p>对预测始终保持怀疑，尤其是宏观数据的预测。每年年底或者年初，都有大量专家或者权威机构发布一些预测数据，比如明年经济如何增长，20年后人口数据将达到什么水平等等。这个预测过程就如同一个黑盒，也许大街上随便找个人猜测也能比他们预测的准，而且他们总是排出稀有事件的影响，但是稀有事件常常具有影响整体的能量。感觉这一部分挺枯燥的，点到为止。</p><p>职业间有一个区分，是否赢者通吃。比如理发师、厨师、医生等，无法通过深耕自己的手艺，做到行业头部水平，然后获取绝大多数的利润。但是歌手、演员、作家等，不鸣则已，一鸣惊人，1%的从业者有可能分90%的蛋糕，销量100万本的书，大概率是一个作者卖出了990万本，一个作者卖出了1w本而不是两个人卖的差不多。在选择职业的时候，也要根据自己的优势和劣势，取迎合或者规避这样的行业，自己能不能坐冷板凳，有没有耐心长期深耕本专业、能不能承受最终还是不能脱颖而出的后果。</p><p>最喜欢作者本书结尾的一段话，特别治愈，原文抄录：</p><p>想象一个10亿倍于地球的行星边缘上的一粒尘埃。这粒尘埃就代表你出生的概率，庞大的行星则代表相反的概率。所以不要再为小事烦恼了。不要再像一个忘恩负义者，得到一座城堡，还要介意浴室里的霉菌。不要再检查别人赠予你的马匹的牙齿，请记住，你就是黑天鹅。</p>]]></content>
      
      
      <categories>
          
          <category> 2024 reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人类简史</title>
      <link href="/2024/04/04/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/"/>
      <url>/2024/04/04/%E4%BA%BA%E7%B1%BB%E7%AE%80%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>2024年初定下了一个目标，每阅读完一本书就要写一点文字记录一下阅读感受，一方面是为了刻意加深印象，另一方面是为了锻炼写作能力。阅读完《人类简史》大概已经一个月了，一直偷懒没有写，清明节有空，想写下来。</p><p>从动物成为神，人依靠的是什么？对人类发展历史最朴实的理解是，在人类发展早期，人和其他动物在生活习惯、力量对比等并没有太悬殊的区别。人类住在山洞里、过着茹毛饮血的生活。但是从现在来看，人类和其他动物依然不能混为一谈，人类从某种视角来说，已经成为了神。是依靠什么，让人类与其他动物走出截然不同的路子的呢？第一个原因，应该是发展出了农业。人类一开始过着采集生活，可能只是某个偶然的发现，早期人类发现可以通过种植获得食物，由此逐渐开始过上定居的生活，自然而然的在周围建设生活设施，将富余的猎物养下来，驯化了动物，过上了越来约富足的生活。另一个更重要的原因是人类可以进行超大规模的协作。一个人斗不过一只狮子，五个人估计也斗不过五只狮子，但是100个人通过沟通、协作，就可以将100只狮子关入笼中，这依靠的就是人类共同的社会协作能力。在现代，通过协作，人类已经实现了很多其他物种不可能实现的事情，有秩序的全球贸易网络、人口众多的国家的有序运行、超复杂工程的顺利实现等，依靠的都是人类制定出的规则和共同遵守这套协作规则的能力。</p><p>人类社会不断发展，人们变得幸福了吗？人类进入农业社会以后，由于粮食生产量的增加，足以养活更多人口，所以人口也爆发式的增长，增长的人口又可以继续投入到开垦田地和农业生产中，如此循环，人口发生了爆炸式的增长。从生物学的角度来说，一个物种的基因拷贝数越多，这个物种就是越成功的，所以人类相比于其他动物来说，物种发展是成功的。但是个人有在随着物种的壮大而变得幸福吗？早期人类过着采集社火，采摘野果，捕猎其他动物，食物富余时也可能几天不用去狩猎，食物缺乏时，一起饿肚子。但是发展进入农业社会以后，食物开始变得更多，就开始出现了精英阶级和剥削。官员、地主等不产与实际生产，但是却分配到了更多的资源。现代社会更是如此，极少数的人掌握着绝大多数的资源，而负责生产的人却越来越忙，生活水平得不到提高。可见，物种壮大对个体而言不一定是好事，因为发展出了分工、法律、高级生产工具等，这些实际上可以成为奴役普通人的绳索。现在国家开始鼓励生育，我理解是因为出现劳动力不足的问题了，但是站在劳动者层面，是应该抵制生育的，劳动力稀缺才能增加劳动者和资本家的议价筹码。出生人口越多，劳动力越廉价，你我就越廉价。</p><p>消费主义盛行，身处其中该何去何从？如果是20世纪中叶是社会主义和资本主义两大阵营，那现在基本上是资本主义一家独大了。资本主义希望资本家将利润投入到再生产中，扩大生产。单只有生产没有消费时不行的，所以还拼命的鼓动社会成员消费各种产品，不管你是否需要，无所不用其极的让大家去购买。由此带来了浪费资源、攀比、物质主义等问题。所以我反对消费主义，因为过度使用不需要的产品，实际上是在支持不必要的扩大生产，由此可能带来环境污染，能源浪费等问题；其次是，过度购买就需要足够的钱，自己就只能不断工作，忙忙碌碌上班却依旧不能产生自己的原始积累，导致自己只能不断工作去支撑自己的购买欲望；还有一个对个人的影响，满目玲琅的商品会分散自己的注意力，这通常会影响自己的内心宁静。</p>]]></content>
      
      
      <categories>
          
          <category> 2024 reading </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023年度总结</title>
      <link href="/2024/01/01/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2024/01/01/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>今天是2024年的一月一日了，终于开始写2024年的年度总结了。本来想昨天写的，但是昨天早上起来就开始打扫卫生，然后去打羽毛球，下午约了济源他们去吃比格自助，晚上一起看了B站的跨年晚会，就把年度总结留到了今天了。其实之前一直犹豫要不要写，因为感觉好像今年很多想做的事都没做，但是又想写一下，回顾一下今年的得失和成长。</p><h2 id="做了哪些事？"><a href="#做了哪些事？" class="headerlink" title="做了哪些事？"></a>做了哪些事？</h2><h3 id="雅思6分"><a href="#雅思6分" class="headerlink" title="雅思6分"></a>雅思6分</h3><p>考雅思这件事的想法由来已久，2021年，大四下学期的时候，课程比较少，闲着没事做就买了资料来复习，后来因为去骑行川藏线搁置了。2022年5月面试微软挂掉了，深感外语的重要性，决心提高英语。</p><p>复习过程战线拉得太长了，所以感觉进步不大。阅读准确率在28&#x2F;40 到34&#x2F;40之间左右徘徊。听力是略有进步的，但是不稳定，正确率从刚开始的18&#x2F;40 到32&#x2F;40之间，两次考试都没发挥好，很遗憾。写作还行，通过看范文，记忆句子等方式，6分还是可以的。口语分数很低，后来想着应该是方法不对，长期通过阅读对话备考的方式效果不好，即便在Cambly上报名模拟练习，也没啥效果，根本原因还是因为口语是长期积累的结果，考试不但是表达，也需要能听清楚，明确理解考官的问题。</p><p>复习到了2023年5月第一次参加考试，总分6分，感觉没发挥好，8月再考了一次，还是6分，报名费也不便宜，就先这样了。就当是打基础了，以后需要成绩证明的时候再去突击吧。</p><p><img src="http://images.zhulk3.cn/blog/ielts1.png"></p><p><img src="http://images.zhulk3.cn/blog/ielts2.png"></p><h3 id="专业能力进步"><a href="#专业能力进步" class="headerlink" title="专业能力进步"></a>专业能力进步</h3><p>要细数在工作技能上有哪些进步，其实不太好衡量，但是升职加薪应该是可以作为一个辅助衡量方式的。春季张新7%，秋季晋升成功张新15%，目前还是算比较满意的。工作技能上的提升还是有一些的：</p><p>编码能力，以Java和Kotlin语言为主，基本是可以熟练使用了，但是以后还需要重点关注Kotlin语言的一些特性，编程时多使用Kotlin，尽量写出地道的Kotlin代码。</p><p>方案设计能力，这非常重要，小到一个需求，大到一个项目，方案设计完善，组织评审以后再去落地开发，这样可以避免返工。而且方案设计文档也是晋升评审中的重要材料。</p><p>性能优化能力，这块确实比较弱，基本没有涉足，以后要刻意培养，这是迈向高阶的必经之路。</p><p>沟通技巧，这个不好说提升了什么，核心关键点就是说话要更加慎重，考略周全以后再说，切记毛毛躁躁，说话考虑不周，这回给自己挖坑，也给别人造成不靠谱的印象。</p><p>一些从工作中积累到的认知：</p><ul><li>功在平时，这是2022年晋升时leader说过的话，现在深以为然。我们所追求的，比较重要的目标，通常不是可以一蹴而就的，设定目标，规划出达成路径以后，应该在平时多积累，多学习，日拱一卒，才有可能实现。</li><li>以终为始，工作以后感觉时间变得特别宝贵，尤其是大脑活跃，效率较高的时段。拿考雅思这件事说，一开始就没有制定明确的目标，只是盲目的复习，花了很多时间，最后收效甚微。感觉这已经是我的一个缺点了，在高中开始就这样，没有考虑目标是什么，怎么实现最为高效，而是花笨功夫去磨。以后做事还是应该定好规划，研究好方案再行动。</li><li>把欲望放到台面上，前两年是带着自己的性格走入职场的，而且学生气太重，不敢表达诉求，不敢正面沟通，不懂得向上管理，这会造成自己工作很努力，但是由于性格原因，导致吃亏。以后要多长个心眼，理解老板的想法，做到方向一致很重要。</li></ul><h3 id="带爸爸北京玩一周"><a href="#带爸爸北京玩一周" class="headerlink" title="带爸爸北京玩一周"></a>带爸爸北京玩一周</h3><p>国庆前一段时间和高中汪同学聚了一下，聊到带父母旅游这件事，突然觉得国庆就是个机会，本希望爸妈一起来北京的，但是妈妈非常抵触出远门，而且也还在上班，所以就只有老爸来北京。国庆期间很多场馆的票很难预定，比如军事博物馆、国家博物馆提前几天都订不到。</p><ul><li>Day1 毛主席纪念堂、天安门广场、故宫、景山公园</li><li>Day2 中国科学技术馆、奥林匹克森林公园、天坛</li><li>Day3 北京大学、颐和园、</li><li>Day4 八达岭长城</li><li>Day4 中国博物馆</li></ul><p>虽然一开始老爸一直说农忙，来了也花钱，但感觉他玩得蛮开心的，在长城上下那些陡峭的台阶像个十几岁的少年一样，脚下生风。</p><p>以后想多带他们走走，多看看这个世界，多一些有刻意留念的时光。</p><p><img src="http://images.zhulk3.cn/blog/father_greatwll.jpeg"></p><h3 id="吃喝玩乐那些事"><a href="#吃喝玩乐那些事" class="headerlink" title="吃喝玩乐那些事"></a>吃喝玩乐那些事</h3><ul><li>爬山，今年大半的时间都在考雅思，所以爬山参与比较少，就组队去了三峰和摘柿子。</li><li>旅游，五月去了青岛，普通意义上的旅游。</li><li>今年尝试了滑雪，第一次就驾驭了双板，下次要尝试双板。</li><li>今年感觉每周都会出去吃，大虾、烧烤、火锅、烤鱼，感觉现在吃饭都有点挑食了。</li></ul><p>2023已经过去了，有得有失，总的来说，还是有进步的。2024，自律起来，成为更好的自己。</p>]]></content>
      
      
      <categories>
          
          <category> 年度总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记录生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读《人间词话》精选十句</title>
      <link href="/2022/10/14/%E8%AF%BB%E3%80%8A%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D%E3%80%8B%E7%B2%BE%E9%80%89%E5%8D%81%E5%8F%A5/"/>
      <url>/2022/10/14/%E8%AF%BB%E3%80%8A%E4%BA%BA%E9%97%B4%E8%AF%8D%E8%AF%9D%E3%80%8B%E7%B2%BE%E9%80%89%E5%8D%81%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p align="center"><strong>落日照大旗，马鸣风萧萧。<strong/></p><p align="center"><strong>细雨鱼儿出，微风燕子斜。<strong/></p><p align="center"><strong>一点浩然气，千里快哉风。<strong/></p><p align="center"><strong>细雨湿流光，芳草年年与恨长。<strong/></p><p align="center"><strong>沙上并禽池上瞑，云破月来花弄影。<strong/></p><p align="center"><strong>可堪孤馆闭春寒，杜鹃声里斜阳暮。<strong/></p><p align="center"><strong>昨夜西风凋碧树。独上高楼，望尽天涯路。<strong/></p><p align="center"><strong>寒波澹澹起，白鸟悠悠下。怀归人自急，物态本闲暇。<strong/></p><p align="center"><strong>自在飞花轻似梦，无边丝雨细如愁，宝帘闲挂小银钩。<strong/></p><p align="center"><strong>浮生长恨欢娱少，肯爱千金轻一笑。为君持酒劝斜阳，且向花间留晚照。<strong/></p>]]></content>
      
      
      <categories>
          
          <category> 阅读记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于尝试微软</title>
      <link href="/2022/05/23/%E5%85%B3%E4%BA%8E%E5%B0%9D%E8%AF%95%E5%BE%AE%E8%BD%AF/"/>
      <url>/2022/05/23/%E5%85%B3%E4%BA%8E%E5%B0%9D%E8%AF%95%E5%BE%AE%E8%BD%AF/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>先说一下结果，面试了四轮，最后挂掉了。</p><p>是找微软HR内推的，很快就收到了phone screen的邀请。phone screen是一轮初步面试，分为项目经理和算法两个部分。算法题是编程计算<em>在一个有障碍物的矩阵中，1表示障碍，0表示可以通过，计算机器人从左上角到右下角的路径总数</em>。用回溯方法做出来了，面试官要求用动态规划，带点小bug也勉强做出来了。第一轮面试反馈不错，这一轮通过才能继续后面的面试。</p><p><img src="https://images.zhulk3.xyz/blog%2Ffeedback"></p><p>接下来是连续三轮面试。</p><p>第一轮是其他部门的同事，问题比较发散，对网络通信和加密比较感兴趣，算法题是<em>给定两个下标，编程交换一个链表中的两个值，值类型为范型。</em>比较简单的一个题，没多想就去遍历，做出来的结果被提醒需要优化。感觉给面试官印象很糟糕，越简单越搞不好。</p><p>第二轮应该是本部门的了，全程笑呵呵的，答得怎么样也不反馈，就像是聊天一样。问题也很发散，算法题是<em>字母a-zA-Z分别映射为1-52这些数字，现在给定一个数字串，编程计算有多少种把数字反射为字母的组合。</em>同样可以使用动态规划计算，需要注意第二位为0的情况。面试结束最后祝我好运，感觉这一轮要挂了。</p><p>第三轮是engineer manager面试，英语问题比较多，一度听不懂。问题还是很发散，Android的MVP和MVVM架构、数据库join方式和职业规划都聊。算法题是<em>指定缓存容量，实现LRU缓存</em>。做了半年的题，就只有这个之前做过。</p><p>面完感觉有机会，但是又感觉很悬。周末两天埋头刷剧等消息，but今天早上等到了面试挂掉的邮件。</p><p>估计今年就继续苟着了，反思下这次面试的过程。</p><ul><li>平时工作不太注意总结，只是想着完成任务。但是面试过程其实是是关注解决问题全过程和提取到的方法论的。平时不总结梳理，回答问题的时候由于别人不了解业务背景，所以总让人不知所云。</li><li>简单问题不要着急，想清楚再回答，简单的问题还出错，只能是减分了。比如这次面试一时口误居然回答使用hash算法进行通信加密，话一出口就想给自己一个大嘴巴。</li><li>对一些常见问题再面试之前应该提前预备答案，比如为什么想尝试这个职位、工作中最激动和最沮丧分别是什么时候，这些问题通常是leader面会出现，答不好感觉就会造成价值观不匹配的印象。</li><li>工作领域的东西还是要一项一项抽时间学会，不管目前工作需不需要。比如MVVM、MVP、Binder。</li></ul><p>结果挺让人沮丧的，这半年又是刷题又是撸项目的，最后半个水花都不起，今年大概不尝试了，继续搬砖。</p><p><img src="https://images.zhulk3.xyz/blog%2Fprogress.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rxJava</title>
      <link href="/2022/03/31/rxJava/"/>
      <url>/2022/03/31/rxJava/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>RxJava是ReactiveX在JVM上的实现，ReactiveX可以利用可观察序列和<a href="https://baike.baidu.com/item/LINQ/4462670">LINQ风格查询操作符</a>来编写异步和基于时间的程序。使用Rx可以通过Observables表示异步数据流，使用LINQ操作符查询异步数据流，用Schedulers参数化异步数据流的处理。可以理解为Rx结合了观察者模式、迭代器模式和函数式编程的特点。</p><h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p>可以理解为观察者模式中的被观察者，会异步的发出事件序列，比如网络请求或者IO等，都可以封装为一个Observable。RxJava将很多Rx提供的操作符实现为了函数，可以通过这些函数对Observable发射出的数据进行操作，继续返回一个Observable对象，这些操作函数可以简化对Observable对象的处理。</p><h3 id="Observable类型"><a href="#Observable类型" class="headerlink" title="Observable类型"></a>Observable类型</h3><ul><li>Flowable，支持背压，当观察者处理发射数据处理不完时，可以执行一些策略，比如抛出错误或者丢弃一些数据。</li><li>Single，只发射一个数据或者错误通知。</li><li>Observable，可以发射不确定数量的数据。</li><li>Maybe，可能发射一个或者不发射数据。</li><li>Completable，用于Observable在完成某件事不发射数据时。</li></ul><h2 id="常用操作符"><a href="#常用操作符" class="headerlink" title="常用操作符"></a>常用操作符</h2><ul><li><p>create 用于创建一个Observable，给这个操作符传递一个接收观察者作为参数的函数，编写这个函数让它的行为表现为一个Observable–恰当的调用观察者的onNext，onError和onCompleted方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Observable <span class="title">createFirstObservable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Integer&gt; subscriber)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!subscriber.isUnsubscribed()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                        subscriber.onNext(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    subscriber.onCompleted();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                subscriber.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将其他种类的对象和数据类型转换为一个Observable, 可以转换Future、Iterable和数组，产生的Observable会发射Iterable或数组的每一项数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Observable <span class="title">createObservableByFrom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Integer[]data = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    Observable observable = Observable.from(data);</span><br><span class="line">    <span class="keyword">return</span>  observable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>just操作符将单个数据转换为发射那个数据的Observable，与from不同，just不会取出数组或者Iterable中的数据逐个发射，而是一整个发射。如下面代码所示，如果我们输出Observable的数据项的size，输出为2，可见是把这个List作为一个数据项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Observable <span class="title">createObservableByJust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhu&quot;</span>, <span class="number">22</span>);</span><br><span class="line">    Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;long&quot;</span>, <span class="number">34</span>);</span><br><span class="line">    List&lt;Student&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    data.add(s1);</span><br><span class="line">    data.add(s2);</span><br><span class="line">    <span class="keyword">return</span> Observable.just(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>map操作符，接收一个转换方法，对Observable发射的数据进行映射操作，返回一个转换以后的Observable。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.map(new Func1() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object call(Object o) &#123;</span><br><span class="line">        return ((Integer)o)+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>distinct只允许发射还没有发射过的数据。RxJava将此操作符实现为一个函数，接收一个函数，此函数返回值为区分数据的key。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Observable&lt;Student&gt; <span class="title">createObservableByFromForDistinct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;zhu&quot;</span>, <span class="number">22</span>);</span><br><span class="line">    Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;long&quot;</span>, <span class="number">34</span>);</span><br><span class="line">    Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;zhu&quot;</span>, <span class="number">34</span>);</span><br><span class="line">    List&lt;Student&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    data.add(s1);</span><br><span class="line">    data.add(s2);</span><br><span class="line">    data.add(s3);</span><br><span class="line">    <span class="keyword">return</span> Observable.from(data);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        createObservableByFromForDistinct().distinct(<span class="keyword">new</span> Func1&lt;Student, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> student.name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">                System.out.println(o.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Student{name&#x3D;’zhu’, age&#x3D;’22’}</strong><br><strong>Student{name&#x3D;’long’, age&#x3D;’34’}</strong><br><strong>onComplete</strong></p></li><li><p>其他操作符，filter用于对Observable发射的数据进行过来，接收的参数为一个谓词测试语句，只发射通过测试的数据；take操作符可以发送前面N项数据，忽略后面的数据。</p></li></ul><h2 id="observeOn"><a href="#observeOn" class="headerlink" title="observeOn"></a>observeOn</h2><p>指定一个观察者在哪个调度器上观察这个Observable，这个观察者的onNext、OnCompleted和onError方法会在指定类型线程运行。</p><h2 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h2><p>操作符是连接观察者和Observable的胶水。一个观察者要想看到Observable发射的数据项，或者想要从Observable获取错误和完成通知，它首先必须使用这个操作符订阅那个Observable。这个方法接收三个方法或者实现了这三个方法的接口的对象。onNext在Observable发射一条数据时调用；OnError, Observable调用这个方法表示它无法生成期待的数据或者遇到了其它错误; onCompleted,如果没有遇到任何错误，Observable在最后一次调用<code>onCompleted</code>之后会调用这个方法。subscribe也可以接受一到三个函数，分别解释为：</p><ul><li>onNext</li><li>onNext和onError</li><li>onNext, onError和onCompleted</li></ul><h2 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn"></a>subscribeOn</h2><p>指定Observable自身在哪个调度器执行。</p>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fail-fast and fail-safe</title>
      <link href="/2022/03/24/fail-fast%20and%20fail-safe/"/>
      <url>/2022/03/24/fail-fast%20and%20fail-safe/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Fail-fast-And-fail-safe"><a href="#Fail-fast-And-fail-safe" class="headerlink" title="Fail-fast And fail-safe"></a>Fail-fast And fail-safe</h1><p>我们可以通过迭代器遍历集合对象，迭代器分为fail-fast和fail-safe两种类型，fail-fast是指当我们通过迭代器遍历集合时，如果集合元素发生了修改，会抛出ConcurrentModificationException异常。fail-safe类迭代器则不会抛出这类异常。</p><h2 id="Fail-fast-case"><a href="#Fail-fast-case" class="headerlink" title="Fail-fast case"></a>Fail-fast case</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt;data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    data.add(<span class="number">1</span>);</span><br><span class="line">    data.add(<span class="number">2</span>);</span><br><span class="line">    data.add(<span class="number">3</span>);</span><br><span class="line">    Iterator&lt;Integer&gt; ptr = data.iterator();</span><br><span class="line">    <span class="keyword">while</span> (ptr.hasNext())&#123;</span><br><span class="line">        Integer a = ptr.next();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        data.remove(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行如上代码，在通过迭代器遍历集合时，对集合进行修改，删除了一个元素，迭代器在遍历时会抛出如下ConcurrentModificationException异常：</p><p><img src="https://images.zhulk3.xyz/tech/3241.png" alt="结果"></p><h2 id="Fail-Fast-Iterators-internal-working"><a href="#Fail-Fast-Iterators-internal-working" class="headerlink" title="Fail-Fast Iterators internal working"></a>Fail-Fast Iterators internal working</h2><p>以ArrayList为例，分析fail-fast的原理。ArrayList有一个迭代器内部类 ListItr, 我们在通过iterator()方法返回ArrayList对象的迭代器时就是返回这个类的一个实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    return new Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类 ListItr 有一个属性expectedModCount，在创建 ListItr 实例时会赋值为modCount，而modCount则是在构建迭代器之前当前ArrayList实例的修改次数，当对ArrayList对象进行修改时，modCount的值都会加1。内部类 ListItr 有一个内部方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在通过迭代器调用next, add, remove, set等方法时，首先会执行如上checkForComodification方法，如果在这之前集合对象发生了修改，那modCount的值增加以后，将会执行if语句中泡出异常的操作。</p><p>但是如果我们使用内部类ListItr自身提供的修改方法，则不会抛出ConcurrentModificationException异常，因为这些方法实现会更新expectedModCount的值。</p><h2 id="Fail-safe-case"><a href="#Fail-safe-case" class="headerlink" title="Fail-safe case"></a>Fail-safe case</h2><p>和fail-fast的迭代器不同，fail-safe类迭代器遍历集合时，如果对集合进行修改，会拷贝一份集合元素的副本，在副本上进行修改，所以不会抛出异常。以CopyOnWriteArrayList为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; data = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    data.add(<span class="number">1</span>);</span><br><span class="line">    data.add(<span class="number">2</span>);</span><br><span class="line">    data.add(<span class="number">3</span>);</span><br><span class="line">    Iterator&lt;Integer&gt;iterator = data.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        Integer a = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (a==<span class="number">2</span>)&#123;</span><br><span class="line">            data.add(<span class="number">4</span>); <span class="comment">//modify while traverse over the collection.</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(String.valueOf(a)+<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://images.zhulk3.xyz/tech/3242.png" alt="结果"></p><p>即时我们在遍历过程中对集合进行了添加元素，也不会体现在遍历结果中，因为是在另一个副本中进行添加的。</p><h2 id="Fail-safe-internal-working"><a href="#Fail-safe-internal-working" class="headerlink" title="Fail-safe internal working"></a>Fail-safe internal working</h2><p>看一下是如何对副本进行操作的，以add方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray(); <span class="comment">//return array, which store the element.</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">//array length incremented to original length + 1, and copy the original elements to newElement array.</span></span><br><span class="line">        newElements[len] = e; <span class="comment">//the last solt is e, which we want to add.</span></span><br><span class="line">        setArray(newElements); <span class="comment">//set the original array reference to newElements.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见添加元素是重新开辟了一份数组空间，添加了元素之后再修改数组引用。CopyOnWriteArrayList的迭代器遍历的却是原来的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>); <span class="comment">//getArray() return the original array reference.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">    cursor = initialCursor;</span><br><span class="line">    <span class="comment">//traverse the array by snapshot, the snapshot is the original array. elements may receive new array </span></span><br><span class="line">    <span class="comment">//value, so we need use snapshot to store its reference.</span></span><br><span class="line">    snapshot = elements; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，使用CopyOnWriteArrayList的缺点也是明显的，首先，由于在副本上进行修改操作，遍历其上的迭代器不能反映出其最新的状态，其次，需要一份额外的内存空间，还需要对元素进行拷贝迁移，这也是很耗费性能的，所以应该尽量在读多写上的场景进行使用。</p><p><em>参考文献</em></p><p><a href="https://anmolsehgal.medium.com/fail-fast-and-fail-safe-iterations-in-java-collections-11ce8ca4180e">Fail-fast and Fail-safe iterations in Java Collections</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RN开发小结</title>
      <link href="/2022/03/24/RN%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93/"/>
      <url>/2022/03/24/RN%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="RN开发小结"><a href="#RN开发小结" class="headerlink" title="RN开发小结"></a>RN开发小结</h1><h2 id="什么是RN"><a href="#什么是RN" class="headerlink" title="什么是RN"></a>什么是RN</h2><p>React Native是Facebook基于React 开源的移动端开发框架，React是一个通过声名式UI构建组件的JavaScript库，React Native结合了原生的流畅和React的特性，是目前比较流行的移动端开发框架之一。通过声明组件，组合这些组件，完成App开发的复杂功能，这些组件虽然都是使用JavaScript开发，但是最终渲染都会使用原生API，所以渲染的流畅程度并不会太差。</p><h2 id="为什么使用RN"><a href="#为什么使用RN" class="headerlink" title="为什么使用RN"></a>为什么使用RN</h2><ul><li>RN具备跨端的特性，目前支持iOS和Android。目前大多数公司的移动端应用都会在iOS和Android两个平台上同时开发，开发一个feature或者修复一个bug，通常需要两个开发人员。使用React Native，开发的程序可以兼容两个平台，虽然有一些差异需要针对特定平台处理，但是还是可以节约一部分开发人力。</li><li>灵活更新，不需要等待发版。使用React Native开发的程序，会被打成bundle，供用户下载使用，不需要等待发版周期，这对于一些紧急需求是非常必要的。而且对于iOS的应用，很多时候应用商店会审核不过，导致用户很难体验到新的功能。一些线上bug可能需要发布热更新或者只能等待下一版本修复，但是React Native可以灵活修复，修复版本可以覆盖几乎所有用户。</li><li>对于开发人员来说，React Native基本上实现了所见即所得，一次修改，快速检验效果，这相比native开发所需要的漫长打包时间，大大提升了开发体验。</li></ul><h2 id="Key-Tech"><a href="#Key-Tech" class="headerlink" title="Key Tech"></a>Key Tech</h2><p>React Native通过声明式UI开发组件，然后组合组件开发出更加复杂的组件。组件分为函数式组件和类组件，函数式组件是无状态组件，类组件具备自己的状态和生命周期方法，后来为了减少类组件中各种生命周期方法的样板代码和复用状态的困难，提供了Hook，使得可以使用函数组件使用state和生命周期等特性。</p><ul><li><p>useState，这是一个hook，我们可以通过它为组件存储一个状态，并在适当的时机修改它。对于一般的变量，函数退出后它就会消失，但是对于useState定义的变量，会被保留。</p></li><li><p>useEffect，可以将其看作以下三个函数的组合，当组件渲染完成以后，我们可能需要执行一些操作，那我们可以将这些操作放到useEffect中调用，useEffect会保存传递的函数，在每次渲染以后调用。有一些操作是需要在组件unmount之后删除的，防止内存泄露，可在useEffect的return语句中返回，进行删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;&#125;  </span><br><span class="line"><span class="function"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>​    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Have a timer call the function every 5 seconds using setInterval</span></span><br><span class="line">    <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></li><li><p>useRef可以用来返回一个可变的ref对象，对象的改变不会触发组件的重新渲染，在整个组件生命周期内是唯一的。</p></li><li><p>useMemo，useMemo返回类型不限的值，只有当依赖项变化时才会触发重新计算，</p></li><li><p>useCallBack，返回可被记忆的回调，每次依赖项改变时，都能生成新的回调。</p></li></ul><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><p>1、在实现两个组件重叠的效果中，往往需要使用绝对定位。使用绝对定位的的组件会脱离文档流，以最近的父布局作为参考，决定位置。但是这必须要指定其自身的高度或者宽度。</p><p>2、使用绝对定位有可能使组件被置于其他组件之下，导致点击事件被屏蔽，可以通过动态修改pointer-events属性来决定是否拦截点击事件。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://segmentfault.com/a/1190000021261588">React Hook</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的同步原语</title>
      <link href="/2022/02/10/Java%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/"/>
      <url>/2022/02/10/Java%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>volatile可以保证修饰变量的可见性和有序性，对于被volatile修饰的变量，对其进行单个读写，等价于被synchronized修饰的读操作或者写操作。</p><h2 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h2><p>实现情况视处理器而定，在intel处理器上，对被volatile修饰的变量进行写操作的指令，在翻译为汇编指令时，会加上lock前缀，处理器在执行这一指令时，会将缓存行中的数据写会内存，其他CPU会通过嗅探总线，如果本地内存内缓存了此变量，会时当前值无效，重新读取。</p><h2 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h2><p>在对volatile进行读写操作指令在编译为字节码时，会通过在指令序列中插入内存屏障指令来预防编译器和处理器为提高执行效率而进行的指令重排序，以此保证执行的有序性。</p><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>java中的每一个对象都可以作为锁，使用synchronized加锁，根据使用场景，有三种不同的情况：</p><ul><li>对于普通同步方法，锁是实例对象；</li><li>对于同步代码块，锁是当前类的Class对象（访问当前类方法和属性的入口）；</li><li>对于同步方法块，锁是括号中配置的对象。<br>synchronized用的锁是存在Java对象头里的，Java对象头中的Mark Word默认存储对象的hashCode，分段年龄和锁标记位。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fd683f43cdf48fb96e5ca44fb8d6832~tplv-k3u1fbpfcp-watermark.image" alt="lock.png"></p><h1 id="fianl域的内存语义"><a href="#fianl域的内存语义" class="headerlink" title="fianl域的内存语义"></a>fianl域的内存语义</h1><p>编译器和处理器对于final域的的处理，在进行重排序时需要遵守两个规则：</p><ul><li>在构造函数内对一个final域的写入与随后将这个引用赋值给其他引用的操作不能重排；</li><li>初次读一个包含final域对象的引用，与随后读这个final域，不能重排。<br>实现以上规则同样是依赖在字节码指令序列中插入内存屏障。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的锁</title>
      <link href="/2022/02/10/Java%E4%B8%AD%E7%9A%84%E9%94%81/"/>
      <url>/2022/02/10/Java%E4%B8%AD%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h1><p>synchronized关键字配合Object类提供的wait(), wait(long timeout),notify(), notifyAll()等方法，可以实现等待&#x2F;通知模式。Condition接口也提供了类似的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"><span class="comment">//进入等待状态，直到其他线程调用signal()或者signalAll()方法进行唤醒。或者其他线程中断当前线程。如果当前线程返回，则已经重新获得锁。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不可中断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时后返回，单位为毫秒</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时后返回，单位为 TimeUnit中的枚举</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时到将来的具体时间</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒所有线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h1><p>synchronized进行加锁时，都是隐式加锁，不容易因为释放锁导致出错，Lock接口需要显式加锁，更加灵活。Lock接口具备synchronized关键字所不具备的灵活性：</p><ul><li>超时加锁，在指定时间内如果尚未获取到锁，返回false，如果在超时等待的时间内被中断，则抛出异常，获取到锁则返回true。</li><li>可以响应中断，在线程获取锁的过程中，可以响应中断，避免死锁发生。</li><li>非阻塞的获取锁，使用synchronized加锁，如果没有获得锁，则会进入阻塞状态，Lock加锁则是进入等待状态。</li></ul><h1 id="AbstractQueuedSychronizer"><a href="#AbstractQueuedSychronizer" class="headerlink" title="AbstractQueuedSychronizer"></a>AbstractQueuedSychronizer</h1><p>AQS的设计是基于模版方法mo模式的，使用者需要继承AQS，重写指定的方法，然后组合到同步组件当中使用。同步组件对外提供的调用方法，可以委托给AQS子类具体执行。</p><h2 id="AQS的使用"><a href="#AQS的使用" class="headerlink" title="AQS的使用"></a>AQS的使用</h2><p>同步器提供了三个方法，可以线程安全的访问同步的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体同步组件只需视情况实现以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//独占式获取同步状态，在具体实现中，需要原子判断当前state是否符合预期（为旧值，其他线程未修改），如果符合，将状态设置为新值。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共享式获取</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共享式释放</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前状态是否被独占</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步组件对外提供了一些模版方法，供外部查询和操作同步状态，这些方法可以支持超时和中断的独占式获取和共享式获取同步状态。值得注意的是，这些方法都已经被final修饰，不可重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AQS的实现"><a href="#AQS的实现" class="headerlink" title="AQS的实现"></a>AQS的实现</h2><h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步器依赖内部的同步队列来完成同步状态的管理，当前线程获取同步状态失败时，会将当前线程以及等待状态信息构成一个Node加入到队尾，同时会阻塞当前线程，当同步状态被释放时，会从队列首部唤醒节点中的线程，使其尝试获取同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NOde的部分字段</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS使用同步队列维护获取同步状态失败而阻塞的的线程，head指向头节点，每次获取状态失败的线程构成节点以后加入队列尾部。首节点是获取到同步状态的线程，当其释放同步状态时，会将首节点设置为其后继节点。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dddceba90c964928b97828668ad86ce7~tplv-k3u1fbpfcp-watermark.image" alt="tail.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetHead</span><span class="params">(Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, headOffset, <span class="keyword">null</span>, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS tail field. Used only by enq.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConcurrentHashMap</title>
      <link href="/2022/02/10/ConcurrentHashMap/"/>
      <url>/2022/02/10/ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="为什么使用ConcurrentHashMap"><a href="#为什么使用ConcurrentHashMap" class="headerlink" title="为什么使用ConcurrentHashMap"></a>为什么使用ConcurrentHashMap</h1><p>HashMap是线程不安全的，在多线程执行put操作过程中，有可能会试容量达到阈值，触发扩容操作，HashMap的扩容操作会将数组容量扩大为当前数组长度的两倍，重新遍历HashMap，将每一个链表中的元素进行重新hash，存入新的HashMap中。如果是多线程进行put，会出现链表成环，导致HashMap的get操作无法结束，CPU利用率达到100%；<a href="https://juejin.cn/post/6844903554264596487">老生常谈，HashMap的死循环</a></p><p>HashTable几乎提供了与HashMap相同的操作，但是HashMap的很多方法都是通过synchronized修饰的，多线程操作会导致线程阻塞，即便是多个只进行查询操作的线程，这样使得效率非常低下。</p><p>我们可以使用Collections提供的封装方法，得到线程安全的Map。但是看了下面SynchronizedMap的实现，是使用了一个Object对象作为锁，同样每一个操作方法都被synchronized修饰了，可见效率也不高。如果需要线程安全且比较高效的HashMap，可以使用ConcurrentHashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SynchronizedMap&lt;&gt;(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="为什么ConcurrentHashMap是线程安全的"><a href="#为什么ConcurrentHashMap是线程安全的" class="headerlink" title="为什么ConcurrentHashMap是线程安全的"></a>为什么ConcurrentHashMap是线程安全的</h1><p>ConcurrentHashMap是由Segment数组和HashEntry数组组成的，Segment是一种可重入锁，HashEntry用于存储键值对数据。一个Segment包含一个HashEntry数组，每个HashEntry是一个链表结构，每个Segment守护一个HashEntry数组的元素，当需要对数组中的元素进行修改时，必须先获得对应Segment的锁。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39ed62b8e2d847d3a683344da92061cd~tplv-k3u1fbpfcp-watermark.image" alt="struct.png"></p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><ul><li>初始化segments数组，通过conrencyLevel计算数组长度，必须是2的整数幂。</li><li>初始化segmentShift和segmentMask，segmentShift用于定位参与散列运算的位数，segmentMask是参与与hash做与运算的掩码，为size-1.</li><li>初始化每一个segment，每一个HashEntry长度同样需要是2的整数幂长度。</li></ul><h1 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h1><p>get操作是不需要获取锁的，因为每一个HashEntry节点的value已经被volatile修饰了，可以保证读到的值是最新的值。<br>定位节点分为两步，首先定位目标segment，然后再定位具体的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash &gt;&gt;&gt; segmentShift) &amp; segmentMask  <span class="comment">// 定位Segment所使用的hash算法 </span></span><br><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);  <span class="comment">// 定位HashEntry所使用的hash算法</span></span><br></pre></td></tr></table></figure><h1 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h1><p>在进行put操作时，首先定位到具体的segment，会对当前segment进行加锁，然后判断是否需要扩容，如果需要扩容，只对当前segment执行扩容操作，最后再添加元素，这不同于HashMap，HashMap添加节点以后进行扩容，如果以后都不再添加元素，这也许是一次无效扩容。</p><h1 id="查询size"><a href="#查询size" class="headerlink" title="查询size"></a>查询size</h1><p>每个Segment使用volatile维护了一个表示当前segment内元素数量的count，但是显然对每个segment中count进行求和的操作不是原子性的。ConcurentHashMap还维护了一个变量，modCount，每次对ConcurrentHashMap中元素的修改操作会使得当前变量加1，所以在对count进行求和之前，保留modCount的副本，在求和以后如果modCount没有发生变化，证明求和这段时间没有线程对容器内元素进行操作，对count的求和是可靠的，如果modCount发生了改变，则需要重新求和，连续两次容器的大小都没有成功正确统计到，则对所有的segment加锁然后求和。</p>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架的使用</title>
      <link href="/2022/02/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/02/10/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>Java集合框架是一类用来存放元素的容器，主要分为实现了Map接口和实现了Collection接口的两类，前者存放的元素是一对key-value的映射，要求key唯一，后者存放的是单个元素，其中实现了Set接口的容器要求容器中的元素不可重复。</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>所谓泛型，就是类型参数话，集合框架下定义的容器希望不被局限于某一类元素，而是一套通用框架，可以存放除基本类型以为的其他类型。在集合容器变量声明时使用某一类型，那么此容器就只能存放这一类型的元素，并且容器中的元素可以调用这一类型元素可以调用的方法。</p><h1 id="Collection类"><a href="#Collection类" class="headerlink" title="Collection类"></a>Collection类</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/962ea9d1d3144161adfcd91ff54b6792~tplv-k3u1fbpfcp-watermark.image" alt="collection.png"></p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList是通过数组实现的List，具有快速随机查找的特点，但是删除元素和插入元素效率较低。常用的API有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object[] <span class="title">toArray</span><span class="params">()</span> <span class="comment">//返回一个包含当前所有元素的数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> <span class="comment">//在指定下标插入元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> <span class="comment">//删除指定下标的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> <span class="comment">//在当前列表后依次添加c中的元素</span></span></span><br></pre></td></tr></table></figure><p>ArrayList实现了Cloneable接口，可以实现存储元素引用的浅拷贝，即两个容器中引用对象仍然相同，实现了Serializable接口，支持序列化和反序列化。</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>使用链表实现，每个节点item引用对象，和next，pre两个指针。LinkedList实现了Deque接口，可以从链表双端对链表进行操作。由于实现方式是链表，所以LinkedList具有插入和删除比较快，随机访问较慢的特点。LinkedList具有很多双端操作链表的API，可以认为如果不带显式的first和last方法，那么删除元素默认在链表尾部进行，添加元素在链表头部进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> <span class="comment">//删除链表首部元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> <span class="comment">//取得链表头节点</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span>  <span class="comment">//取得链表尾节点</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p>LinkedList不是线程安全的，如果有多个线程同时对LinkedList的结构进行修改（增加或者删除节点），有可能会导致链表出现环状。可以使用如下方法进行包装得到线程安全的List。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</span><br></pre></td></tr></table></figure><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector是线程安全的，有可能引起线程不安全的操作和获取相关Vector信息的值的方法都被synchronized修饰了。但是在不要求线程安全的场景下，推荐使用ArrayList代替Vector，性能更好。</p><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>Stack是继承自Vector的集合，具有后进先出的特点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet实现了Set接口，可以保证元素的容器中元素唯一，但是不保证有序。HastSet是通过<a href="https://juejin.cn/post/7044795520031653925">HashMap</a>实现的，保证容器中元素唯一的方式是，每次插入的元素实际是作为(key,value)中的key，value是一个Object对象，HashMap是可以保证存入元素key是唯一的，所以HashSet能够保证容器中的元素唯一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashSet同样是线程不安全的，如果需要在多线程场景中使用hashSet，推荐如下封装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set s = Collections.synchronizedSet(<span class="keyword">new</span> HashSet(...));</span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>继承自HashSet，与HashSet相同，可保证元素唯一，使用LinkedHashMap实现，可以保证插入元素顺序可知。</p><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>实现了SortedSet接口，可以保证容器内元素不重复，可排序。</p><h1 id="Map类"><a href="#Map类" class="headerlink" title="Map类"></a>Map类</h1><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/554b9ade16d14634ad00752ada96d6df~tplv-k3u1fbpfcp-watermark.image" alt="map.png"><br>实现了Map接口的容器类用来存放的元素是一组key到value的映射关系，LinkedHashMap继承自HashMap，可以在HashMap的基础上保证存入顺序是可知的。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><a href="https://juejin.cn/post/7044795520031653925">HashMap</a></h2><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedHashMap实现这一功能的方式是，其中的每一个节点，都有两个指针，before和after，分别指向前一个插入节点，和后一个插入的节点。</p><p>LinkedhashMap是如何保证插入顺序有序的？重写了HashMap的newNode方法，将当前插入节点的before指针指向了插入前的尾节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; scores = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    scores.put(<span class="string">&quot;chemistry&quot;</span>, <span class="number">93</span>);</span><br><span class="line">    scores.put(<span class="string">&quot;math&quot;</span>, <span class="number">98</span>);</span><br><span class="line">    scores.put(<span class="string">&quot;biology&quot;</span>, <span class="number">92</span>);</span><br><span class="line">    scores.put(<span class="string">&quot;english&quot;</span>, <span class="number">97</span>);</span><br><span class="line">    scores.put(<span class="string">&quot;physics&quot;</span>, <span class="number">94</span>);</span><br><span class="line">    scores.put(<span class="string">&quot;chinese&quot;</span>, <span class="number">99</span>);</span><br><span class="line">    scores.put(<span class="string">&quot;geography&quot;</span>, <span class="number">95</span>);</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = scores.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; score = iterator.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;subject: &quot;</span> + score.getKey() + <span class="string">&quot; score: &quot;</span> + score.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38bec6196f504c888b765e176676281d~tplv-k3u1fbpfcp-watermark.image" alt="map_answer.png"></p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>基于红黑树实现的，对可对key进行排序的NavigableMap。</p><p>reference：<br><a href="https://zhuanlan.zhihu.com/p/34490361">https://zhuanlan.zhihu.com/p/34490361</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的使用</title>
      <link href="/2022/02/10/HashMap%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/02/10/HashMap%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="Node和初始化"><a href="#Node和初始化" class="headerlink" title="Node和初始化"></a>Node和初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//hashCode通过key于value计算得到</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>哈希桶的大小，默认为16，如果自定义，需要为2的n次幂，这样可以使用与运算高效的代替模运算。</li><li>负载因子，负载因子*数组长度等于容量阈值。</li><li>阈值，当前HashMap中元素元素超过阈值，需要扩容，防止各种操作hash冲突增多，效率变低。<h2 id="hash和寻址"><a href="#hash和寻址" class="headerlink" title="hash和寻址"></a>hash和寻址</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">index = hash&amp;(tab.length-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>hash值通过key的hashCode异或本身高位得到的，这样可以让高位参与运算，否则hash值异或(tab.length-1)将不能利用hash值的高位，导致hash冲突变多。</li></ul><h2 id="put过程"><a href="#put过程" class="headerlink" title="put过程"></a>put过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//判断数组位置是否已经插入元素，如果没有就插入数组中</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">//通过hash和key确定，是否key相同，是的话覆盖value即可</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//判断是不是转为了红黑树，是的话将此节点插入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//循环遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">//到达尾部，没有找到key相同的节点，插入尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="comment">//找到key相同的节点，直接返回，执行1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1，在key相同的节点，修改value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//size大于阈值，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get过程"><a href="#get过程" class="headerlink" title="get过程"></a>get过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">//首先通过hash值在哈希表数组中寻找，如果hash和key都符合，则表示找到，可以返回</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123; <span class="comment">//出现hash冲突，</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果子节点是树节点，在红黑树中寻找</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="comment">//循环遍历链表，在链表中查找</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>在容量超过阈值以后，会进行扩容，数组容量是当前数组的两倍。扩容后会为当前HashMap中每一个桶中的元素重新寻址，新的下标是e.hash&amp;(newCapcity-1)。如果新的hash桶中已有元素，则类似插入元素的方式将当前元素插入hash表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        next = e.next;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">//决定存在数组高位还是低位</span></span><br><span class="line">            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e; <span class="comment">//会形成一个链表，link_1;</span></span><br><span class="line">            loTail = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;  <span class="comment">//也会形成一个链表，link_2;</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">        newTab[j] = loHead; <span class="comment">//存link_1在新数组低位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">        newTab[j + oldCap] = hiHead; <span class="comment">//存link_2在数组高位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Executor框架的使用</title>
      <link href="/2022/02/10/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/02/10/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在Executor框架中，工作单元包括Runnable和Callable，执行机制由Executor框架提供。</p><h2 id="两层调度模型"><a href="#两层调度模型" class="headerlink" title="两层调度模型"></a>两层调度模型</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b99fd61c3af04612a63ef8cc00292289~tplv-k3u1fbpfcp-watermark.image" alt="executor.png"></p><p>多线程程序将任务分解为多个任务，然后由用户级调度器Executor将这些任务交由Java线程执行。Java线程并不是直接被CPU调度执行，还会映射为操作系统内核线程，由内核调度器将内核线程调度到CPU执行。祥见<a href="https://www.kancloud.cn/zhangchio/news/754628">Java线程和os线程</a></p><h2 id="Exectuor框架的结构"><a href="#Exectuor框架的结构" class="headerlink" title="Exectuor框架的结构"></a>Exectuor框架的结构</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dc4064f4fbd406698cb1d25657c3a42~tplv-k3u1fbpfcp-watermark.image" alt="worker.png"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/249b3e055ce14c6897c9423fc3531b7a~tplv-k3u1fbpfcp-watermark.image" alt="manager.png"><br>Executor框架由三大部分组成：</p><ul><li>任务，包括被执行任务需要实现的接口，Runnable接口和Callable接口；</li><li>任务的执行，任务机制的和讯即接口及其实现类，ThreadPoolExecutor和ScheduledThreadPool;</li><li>异步计算的结果，Future及其实现类FutureTask；</li></ul><h3 id="Executor框架的使用"><a href="#Executor框架的使用" class="headerlink" title="Executor框架的使用"></a>Executor框架的使用</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/111948a08b1a4519b063a97bc121047d~tplv-k3u1fbpfcp-watermark.image" alt="use.png"><br>主线程创建一个Runnable或者Callable任务（Executor可以将Runnable类型转换为Callable类型），然后交给Executor执行，主线程通过返回的Future接口，阻塞等待任务执行以后返回结果，也可以在等待过程中取消任务执行。</p><h3 id="Executor框架核心类"><a href="#Executor框架核心类" class="headerlink" title="Executor框架核心类"></a>Executor框架核心类</h3><ul><li>ThreadPoolExecutor，线程池的核心实现类，用来执行被提交的任务。通过工厂类Executors实现三种类型线程池：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心线程数和最大工作线程数量相等，避免创建大量线程，适用于服务器负载较重的情况。</span></span><br><span class="line"><span class="comment">//使用无界队列LinkedBlockingQueue作为任务管理队列，意味着线程池中工作线程不会超过核心线程。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有核心线程，最大工作线程取整数的最大值，适用于有比较多短期的小任务场景；</span></span><br><span class="line"><span class="comment">//使用SynchronousQueue作为工作队列，当主线程提交任务速度大于线程处理速度时，会不断创建线程，有可能会因为创建过多线程导致CPU和内存耗尽</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只会创建一个工作线程，适用于需要保证顺序的执行各个任务的场景。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor用于在固定延迟后执行任务，通过Executors创建，包括两种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只会创建单个核心线程，工作线程为Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DelegatedScheduledExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, threadFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以设置多个核心线程,工作线程为Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runnable接口和Callable接口的实现类，都可以交个线程池执行，不同的是Callable接口可以返回结果.也可以将一个Runnable对象封装为Callable对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用DelayWorkerQueue作为工作队列，这是一个无界阻塞队列，使用PriorityQueue实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d0498dc7cd647109a4b33eb05b8c507~tplv-k3u1fbpfcp-watermark.image" alt="schedule.png"><br>主线程向DelayWorkerQueue中添加任务时，任务会被包装为ScheduledFutureTask，线程池中的线程会从队列中取出任务执行。</p><h3 id="ScheduledThreadPoolExecutor的实现"><a href="#ScheduledThreadPoolExecutor的实现" class="headerlink" title="ScheduledThreadPoolExecutor的实现"></a>ScheduledThreadPoolExecutor的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">    <span class="keyword">super</span>(callable);</span><br><span class="line">    <span class="keyword">this</span>.time = ns; <span class="comment">//表示这个任务将要被执行的具体时间</span></span><br><span class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>; <span class="comment">//表示任务执行的间隔周期，</span></span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement(); <span class="comment">//被添加入任务队列的顺序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DelayQueue中的任务是ScheduledFutureTask类型，包括三个成员变量。DelayQueue封装了一个PriorityQueue，会根据ScheduledFutureTask的time和sqquenceNumber进行排序。线程池中的线程会从任务队列中取出time大于当前时间的任务进行执行。在执行结束以后，会更新time，重新将任务放回队列之中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p = period;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">        time += p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        time = triggerTime(-p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>由于FutureTask继承了Future接口和Runnable接口，所以可以把一个FutureTask接口交由实现了Executor的线程池执行，也可以作为计算结果返回,然后执行FutureTask.get()阻塞当前线程等待返回计算结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br></pre></td></tr></table></figure><p>FutureTask是基于AbstractQueuedSynchronizer（AQS）实现的，很多可阻塞类都是基于AQS实现的，AQS是一个原子框架，提供了通用机制来原子性的管理状态，阻塞和唤醒线程，以及维护被阻塞线程的队列。对于很多阻塞类，其具体操作都会委托给实现了AQS的内部类Sync，由Sync进行具体的操作。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53f063b85502467189b0decd26a66027~tplv-k3u1fbpfcp-watermark.image" alt="aqs.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池的使用</title>
      <link href="/2022/02/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/02/10/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="使用线程池的益处"><a href="#使用线程池的益处" class="headerlink" title="使用线程池的益处"></a>使用线程池的益处</h2><ul><li>避免重复创建线程执行任务，减少了创建线程和销毁线程需要的时间开销和性能开销；</li><li>提高任务响应速度，线程池中通常缓存有线程，当提交任务以后，可迅速执行；</li><li>避免了无规则的创建大量线程，导致大量线程排队等待CPU，响应速度变慢；</li></ul><h2 id="线程池处理流程"><a href="#线程池处理流程" class="headerlink" title="线程池处理流程"></a>线程池处理流程</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59976e0fd2fe42d9862b3db3be1aa4d1~tplv-k3u1fbpfcp-watermark.image" alt="stage.png"></p><p>我们可以调用线程池的execute和submit方法来提交任务，提交参数都是一个Runnable实例，不同的是，submit会返回一个Future类型的对象，可以通过future对象的get方法获得返回值，注意这个方法会阻塞当前线程。</p><ol><li>当一个任务提交给线程池时，如果当前线程池中线程数量少于核心线程数，会重新创建新的线程执行这个任务，然后通过线程安全的方法更新当前线程数。注意，当提交一个任务给线程池时，线程池会创建一个核心线程来执行，即使其他核心线程空闲，直到核心线程达到预设值。</li><li>如果当前线程数已经大于或者等于核心线程数，那会尝试判断阻塞队列是否已满，未满的话将任务加入到阻塞队列中。</li><li>已满则判断当前线程池数量是否小于最大线程数量，如果是的话，创建工作线程执行，否则的话执行拒绝策略。</li></ol><h2 id="线程池参数说明"><a href="#线程池参数说明" class="headerlink" title="线程池参数说明"></a>线程池参数说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//核心线程数</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize, //最大工作线程数，不能小于corePoolSize</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime, //非核心线程超时时间，闲置时间超过会被销毁</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue, //用于保存等待执行的任务的阻塞队列</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler //拒绝策略)</span></span></span><br></pre></td></tr></table></figure><p>阻塞队列有很多种,newCachedThreadPool使用SynchronousQueue，这种阻塞队列不存储任务，每个插入操作必须等待一个线程执行取出操作，否则插入线程阻塞。newFixedThreadPool则使用LinkedBlockingQueue。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a92003860de484f9303698e8db22999~tplv-k3u1fbpfcp-watermark.image" alt="handle.png"></p><p>拒接策略分为四种，分别是直接只用调用者所在线程执行任务、直接抛出异常、丢弃队列里等待最长时间的任务，执行当前任务、或者直接丢弃掉当前任务。</p><h2 id="配置线程池"><a href="#配置线程池" class="headerlink" title="配置线程池"></a>配置线程池</h2><p>根据不同的情况配置线程池：</p><ul><li>根据任务性质，比如是CPU密集型还是IO密集型，CPU密集型应该配置尽可能少的线程，防止线程持续等待CPU分配时间，IO密集型就可以多一些线程，因为大部分线程可能在等待IO；</li><li>任务优先级，是否有些任务是高优执行的，可以使用ProrityQueue作为阻塞队列。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的并发工具类</title>
      <link href="/2022/02/10/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2022/02/10/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>Java中有许多工具类可以在并发场景中使用，简化并发编程难度，提高程序准确性。</p><h2 id="CountDaowLatch"><a href="#CountDaowLatch" class="headerlink" title="CountDaowLatch"></a>CountDaowLatch</h2><p>可以实现类似于fork-join模型提供的功能，在多线程场景中，用于等待其他线程完成的线程可以调用countDownLatch的await方法进入等待状态，只有当其他线程将CountDownLatch中保存的值递减到0时，等待线程才会继续运行。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>)；</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;continue&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(<span class="string">&quot;continue&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadOne.start();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f273d1dd6c2147cdb5145ee3dfa042ac~tplv-k3u1fbpfcp-watermark.image" alt="answer.png"></p><p>运行结果总是相同，主线程在运行到await时，会进入等待状态，只有当子线程两次执行完countDown之后，主线程才会继续执行。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>查看CountDownLatch的实现，可以看到在new一个CountDownLatch时，需要一个int类型的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Sync是CountDownLatch的一个继承了AbstractQueuedSynchronizer的内部类，用于实现同步控制，具有一些列加锁和解锁的方法。构造CountDownLatch时传入的参数最终用来设置一个被volatile修饰的属性state。这个state值可以理解了当前所有线程可重入的获得了多少锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>countDown会将当前的state值减1，这可以理解为释放一把锁的过程。</p><p>当主线程调用await方法之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果当前的state没有减到0，主线程就会去执行doAcquireSharedInterruptibly,这个方法会使得主线程不断死循环的去获取“锁”，或者直到中断，直到state减少到0，主线程才能得到“锁”，解除循环，继续执行。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><p>可以用于做流量控制，限制多线程对有限资源的访问，在多并发场景下，如果资源数量有限，只能够支持有限的线程的使用，可以使用信号量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>; <span class="comment">//线程规模</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span> * THREAD_COUNT; i++) &#123; <span class="comment">//任务数量远大于线程数</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        s.acquire();  <span class="comment">//获取信号量</span></span><br><span class="line">                        printThreadCount();</span><br><span class="line">                        s.release(); <span class="comment">//释放信号量</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printThreadCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前可用许可证数：&quot;</span>+s.availablePermits() + <span class="string">&quot; 等待线程数&quot;</span> + s.getQueueLength());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d5e7abb9e634cf0833e479611c11b0b~tplv-k3u1fbpfcp-watermark.image" alt="ww.png"></p><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">    setState(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在初始化Semaphore时，默认构造非公平的同步器，传入参数为信号量的值。<br>在线程执行到acquire时，会尝试可中断的去获取信号量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)    </span><br><span class="line">        doAcquireSharedInterruptibly(arg);  <span class="comment">//1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;<span class="comment">//目前剩余信号量，小于0证明已经无可用</span></span><br><span class="line">        <span class="comment">//尝试判断，小于0或者原子重置信号量值失败，都会返回负值，然后进入等待队列</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在释放信号量以后，会通过原子操作给state值加一，如果当前state的值大于0，会在等待队列中唤醒队列首部的线程去获得信号量。</p>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的原子类</title>
      <link href="/2022/02/10/Java%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
      <url>/2022/02/10/Java%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在多线程读写共享变量的场景中，很容易出现数据竞争，导致数据不一致。Java提供了<strong>synchronized</strong>关键字和<strong>Lock</strong>接口来保证多线程对同步块的有序访问，但是这两种方式都需要隐式或者显式的获取锁，性能开销略大。Java的Atomic包提供了多个原子操作类，可以安全、高效、简单的实现在多线程场景下读写变量。Atomic包中的类基本上都是使用Unsafe实现的包装类。</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>包括诸多方法实现整型数据的原子操作。比如对于整数的递增操作i++，由于这一操作并不是原子的，所以即便使用volatile修饰也不能保证线程安全，这种场景就可以使用AtomicInteger的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下通过AtomitInteger的addAndGet方法来分析这一原子类是如何实现线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically adds the given value to the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueOffset the value memory address.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var5是通过native方法取得的当前变量的值，compareAndSwapInt通过原子操作，将预期的的结果var5+var4替换为当前变量的值var5，如果方法成功就，compareAndSwapInt返回ture，循环结束，如果返回false，说明有其他线程在这段时间修改了当前变量的值，会重新通过循环获取var5，继续重试。</p><h2 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h2><p>实现原理与AtomicInteger基本相同，核心思想是将true和false映射为1和0。int类型的value存储的就是当前AtomicBoolean的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> AtomicBoolean&#125; with the given initial value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicBoolean</span><span class="params">(<span class="keyword">boolean</span> initialValue)</span> </span>&#123;</span><br><span class="line">    value = initialValue ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets to the given value and returns the previous value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">boolean</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> prev;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, newValue));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">boolean</span> expect, <span class="keyword">boolean</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e = expect ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//将boolean类型映射为int类型</span></span><br><span class="line">    <span class="keyword">int</span> u = update ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, e, u);<span class="comment">//通过原子操作更新当前值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h2><p>更新数组的值是通过调用其他原子更新基本类型或者引用类型来实现的，重点在于通过数组下标获得当前值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">updateAndGet</span><span class="params">(<span class="keyword">int</span> i, IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> offset = checkedByteOffset(i);<span class="comment">//得到下标在内存中的地址</span></span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = getRaw(offset);</span><br><span class="line">        next = updateFunction.applyAsInt(prev);<span class="comment">//转为int</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSetRaw(offset, prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在内存中取得当前值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRaw</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getIntVolatile(array, offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以原子方式修改数组偏移量的值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndSetRaw</span><span class="params">(<span class="keyword">long</span> offset, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(array, offset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="原子更新引用"><a href="#原子更新引用" class="headerlink" title="原子更新引用"></a>原子更新引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> longkai;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;User&gt;();</span><br><span class="line">        User firstUser = <span class="keyword">new</span> User(<span class="string">&quot;long&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        atomicReference.set(firstUser);</span><br><span class="line">        User secondUser = <span class="keyword">new</span> User(<span class="string">&quot;kai&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        atomicReference.compareAndSet(firstUser, secondUser);</span><br><span class="line">        System.out.println(atomicReference.get().getName());</span><br><span class="line">        System.out.println(atomicReference.get().getAge());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>通过查看源码，最后发现Unfase类只提供了三种CAS方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前值为var4，则将值更新为var5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var5)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与AtomicBoolean类似，原子更新char、short、float、double可以实现。CAS算法是一种乐观锁的实现思想，在更新变量之前不对更新操作进行加锁，而是在更新之后再去看当前变量内存地址的值有没有发生改变，如果没有，就将希望更新的值写入到内存，如果发生了更改，则继续重试。</p>]]></content>
      
      
      <categories>
          
          <category> 技术积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在冬季和北京再次相遇</title>
      <link href="/2020/11/19/%E5%9C%A8%E5%86%AC%E5%AD%A3%E5%92%8C%E5%8C%97%E4%BA%AC%E5%86%8D%E6%AC%A1%E7%9B%B8%E9%81%87/"/>
      <url>/2020/11/19/%E5%9C%A8%E5%86%AC%E5%AD%A3%E5%92%8C%E5%8C%97%E4%BA%AC%E5%86%8D%E6%AC%A1%E7%9B%B8%E9%81%87/</url>
      
        <content type="html"><![CDATA[<p>昨天晚上八点到的北京，从广州穿着短袖飞越两千多公里，下飞机以后穿着和路人显得格格不入，大家都是穿着厚厚的棉袄了。</p><p>走了二十多分钟到之前订的民宿里暂住一晚，一路上是那种好久没有感觉过的冷。房东是个大学老师，很客气。十一点吃完外卖直接睡下了，感觉还是没有住酒店轻松，民宿总感觉不方便，比如担心声音大了一点惹主人家不高兴。</p><p>早上起来赶到回龙观和房东谈房子，感觉北京的空气比前些年要好很多了，很明显有那种高纬度地区天空纯洁的感觉。前几天从广州寄的被子今天刚好送到，不早不晚，可以直接用上。</p><p>秋招的offer拿到的全是北京的公司。在面试时很多面试官都会问我为什么要来北京？和同学说我打算去北京，他们也会问为什么要去那么远呢？北京空气质量不好，气候干燥，交通还拥堵。这些都是我真真实实要面对的问题，</p><p>但是我还是没有打算去其他城市，我觉得北京对于我有一种莫名的吸引力，或许是他深厚的文化底蕴，或许是他领先的经济发展水平，或者是他各类的活跃人才，这些也许其他城市也有，但总不能和北京比肩。在北京工作的经历会是一段富有意义的经历，这样的经历，越早越好。</p><p>近来也会思考人生的意义，以前觉得人生应该最求快乐，怎样快乐就怎样去度过一生，但是现在不这么觉得了，人生应该是追求充实，同样要去接纳苦难和波澜不惊，应该去领略各式各样的人生，如果总是快乐的，不免显得太单调无味。</p><p>距离今年春节已经不足三个月了，发现手里的事情还蛮多的，而且都有难度，毕业设计已经提上日程，目前还没有方向，想要在春招转后端开发，但是要学的东西还有很多，在快手的实习工作量应该会很足，也担心一些工作可能做不好，嗯，是的，不会说做完什么事就没事了，事情永远一件接一件，那，干就完了。</p>]]></content>
      
      
      <categories>
          
          <category> 人生履历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上海外滩之夜</title>
      <link href="/2020/04/26/%E6%B5%B7%E5%A4%96%E6%BB%A9%E4%B9%8B%E5%A4%9C/"/>
      <url>/2020/04/26/%E6%B5%B7%E5%A4%96%E6%BB%A9%E4%B9%8B%E5%A4%9C/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>来上海一周了，一切都好，因为自己前端基础比较薄弱，每天在公司会学很多东西，感觉很充实，很有成就感，但是每当晚上八九点独自一人回到住处，强烈的孤独感就会袭来，是一种让人心慌，不知所措的感觉。</p><p>昨天是星期六，来这里以后的第一个休息日，但是对这里都不熟，也不知道去哪里，只好一觉睡到十点。下午复习了一下课程，决定晚上出去走走，否则漫漫长夜实在难挨。东方明珠是小学课本里出现的，也一直作为上海的标志和上海联系在一起，出了地铁就看到了，但真的略感失落，因为她好像不是想象中的那么高大，尤其是在和周围那么多金融大厦相比。</p><p>走在黄埔江边，和王金梅聊了一路，感觉就没那么孤独了，孤独应该是要倾诉的吧。现在可以好好聊聊真心话的朋友真的越来越少了，不知为何，只能接受。天南地北聊了很久，我都忘记自己已经走了多远了。在意识到应该回去了才发现距离地铁站已经很远了，狠心想打车回去，奈何手机还没等到车来就没电关机了。立刻意识到情况不妙，地铁停运，手机没电，可能回不去了，只能趁现在江边还有人赶紧返回东方明珠附近，那里应该相对安全，一路快走，脚掌也不疼了，本来刚才散步就有点疼了。</p><p>已经十一点半了才走回到东方明珠塔下，幸好有一个保安亭可以充电，本来想央求他收容一晚上的，无奈他太不近人情了。一点钟充电差不多了，也不打算再去找住处了，现在到处跑也不安全，就在保安亭旁边角落做一晚上吧，和保安在一起应该更安全一点。从五个小时，一万八千秒倒数，晚上是真的有点冷，最冷的时候应该是凌晨四点钟的时候。先是坐地板上，发现地板太僵了，然后站着，站不动就蹲着，期待着黎明的到来。凌晨三点钟看到一个中年男人来翻垃圾桶，生活是有多难呢？凌晨四点钟就有人起床锻炼了，真的佩服；偶然听到那个保安和朋友聊天，他拒绝去工厂，太累了，还是当保安轻松，我就在想难道你可以做一辈子保安吗？凌晨四点钟就鸟儿就开始出来觅食了，叽叽喳喳的好多，我还以为城市没有鸟呢。</p><p>熬到五点，已经是黎明了，还好回去睡两个小时还赶得上上班。</p>]]></content>
      
      
      <categories>
          
          <category> 人生履历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在美团点评的第一天</title>
      <link href="/2020/04/20/%E5%9C%A8%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%84%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
      <url>/2020/04/20/%E5%9C%A8%E7%BE%8E%E5%9B%A2%E7%82%B9%E8%AF%84%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<p>今天是入职美团点评开始实习的第一天，是来到上海的第三天。在第一天晚上住的那个酒店里放了一个体重称，称了一下体重，133斤，果然，这三个月假期肥了7斤，比大学两年半肥的还要多。对于我来说，没有学习和工作的氛围，自律的学习和生活就不可能。</p><p>赶紧滚出舒适圈，今年行情不好，还是早些谋划出路。当混子的时间长了，连方向都分不清，先把三明北的高铁票买成了三明站，幸好没耽误下一程，然后把自己工作的地点弄错，之前联系要租的房子前功尽弃，在找房子的前一天晚上十二点还临时上网找房子，又把酒店定在了和公司截然相反的方向，行李箱都在漫长的换乘地铁的过程中拉坏掉，真的是路遥马亡。</p><p>今天入职，真正的开始把知识运用到工程。在办理入职手续的时候见到了很多也是今天入职的同龄人，感觉挺好的，年轻人比较多。HR联系徐斌学长接到了我，然后见到了部门leader，就是二轮面试的面试官，还记得当时聊了一个多小时，虽然很多问题我都答不出来，他也会给我解答一下，真人比视频上年轻是真的。部门工位满了，只能到隔壁部门借坐两天，这也挺好，和他们在一起自己那些low比操作怕是要被笑死。mentor是个应该毕业一两年的女生，虽然年纪轻轻，但是项目构思、技术表达都非常严谨和清晰，在今天晚上的小组周会上可见一斑。</p><p>八点下班走人，住得近真的好，可以步行上下班，早晚高峰挤地铁的事情我是不用体验了。回来接到了爸爸的电话，多是些叮嘱我这个涉世未深的小孩应该如何处理职场的人情世故。还记得在家面试的时候，每次面试妈妈都会问这家公司是哪里的，其实说了在哪个城市她也不知道，也还是要问问，应该是希望工作得城市不要太远吧。</p><p>要开始接收新任务了，还是赶紧学习，在被认出是菜鸡之前变得稍微强一点。</p>]]></content>
      
      
      <categories>
          
          <category> 人生履历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对每一个不曾到达的地方，都要心怀向往</title>
      <link href="/2020/04/09/%E5%AF%B9%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9B%BE%E5%88%B0%E8%BE%BE%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%8C%E9%83%BD%E8%A6%81%E5%BF%83%E6%80%80%E5%90%91%E5%BE%80/"/>
      <url>/2020/04/09/%E5%AF%B9%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%9B%BE%E5%88%B0%E8%BE%BE%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%8C%E9%83%BD%E8%A6%81%E5%BF%83%E6%80%80%E5%90%91%E5%BE%80/</url>
      
        <content type="html"><![CDATA[<p>放假已经快三个月了，因为疫情，才可以和爸妈在一起那么久，过完年就开始复习找实习，也准备了快三个月了，真的非常幸运，拿到了美团点评的Android工程师实习offer，否则我现在真的会焦虑死吧。</p><p>年后就在想，实习应该找什么岗位呢，自己大学学习的那些课程好像不足以应对工作，好像做什么都要从零开始，最终决定选择Android开发，是因为算法岗自己肯定不行，后台开发竞争太大了，前端庞杂难以短时间掌握，iOS开发目前没有硬件练习，测试门槛太低了，就只有Android是最优解了。整个准备的过程需要复习和学习的东西还是蛮多的，计算机网络、操作系统、数据库、Java、Android、JVM、设计模式等都要去学习，还要时常刷一点算法题。整个过程有一种山重水复疑无路，柳暗花明又一村的感觉。</p><p>3月10左右开始投简历，都忘记投了多少家公司了，每天都会去看一下简历状态，等待面试真的是很难受的一个过程。一开始面试的是蘑菇街，第一轮面试就挂掉了，然后小米、盛趣游戏、字节跳动、腾讯、CVTE等相继挂掉，虽然每一轮面试都入真准备，但是小厂需要可以直接干活的，大厂需要学习能力各方面都很优秀的，那我真的就没有去处了。</p><p>我一直感觉我是一个很幸运的人，特别是在一些人生的关键节点，都会遇到贵人相助，这次也不例外。美团点评也算大厂了，在美团点评面试之前就有一位美团点评iOS工程师打电话给我，希望我转iOS，让我好好准备笔试，这给我很好的心理暗示，然后面试的时候是一位女生面试官，人很友好，问的问题很简单，问题答不对也会引导，40分钟就结束面试了，当天就收到了第二次面试和第三次面试的邀请，这又给我了很好的心理暗示，难道默认第二轮面试通过吗？我想得太美了，第二轮是一个leader，一个多小时的面试都是基础知识轰炸，虽然很大都没有答出来，但是他还是给我过了。第三轮面试相对就比较轻松了，面试官人很好，天南地北的都聊。第二天就收到了offer call，下周一就收到了offer通知，曾为此不遗余力的复习，也曾辗转反侧的煎熬等待，终于所得届时所想，心中喜悦之情，难以言表。</p><p>在最近几次面试中，反复被问到了了对职业生涯有什么规划，没有想过的问题，自然回答得一团糟，但这个问题不可以回避，也无法回避，真的需要规划自己得职业生涯了，那种庸庸碌碌的校园生活所剩无几了。</p>]]></content>
      
      
      <categories>
          
          <category> 实践心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>想要问问你，生活可如意</title>
      <link href="/2019/12/28/hello2020/"/>
      <url>/2019/12/28/hello2020/</url>
      
        <content type="html"><![CDATA[<p>在过3天就是2020年了，又一个十年的伊始。</p><p>回想过去十年应该是很惬意的十年，小学到初中在到高中，还有不紧不慢的大一大二两年，都过得潇洒恣意，也取得些许成就，至少无愧于自己也无愧于亲友。</p><p>现在的我说话已经时常用成年人打头了，成年人不能畏畏缩缩没有担当、成年人不能理所当然的继续成为家里的负担、成年人不能一事无成。</p><p>越是经常这样想就越是觉得失落。今年一心想着修学分，选课选得多了一些，再加上自己的资质是在过于平庸，一个学期下来整天围着作业打转，上半学期还好，还能勉强跟上，下半学期尤其是接近期末这段时间，只能是糊弄作业了，为此时常觉得难受。这种感觉在和同学们的对比总尤为强烈，自己进步得实在是太慢了，再仔细想想，自己有进步吗？</p><p>暂时先麻木吧，心为形役，挨过这个学期再说。</p><p>今年的下半年开始，考研和实习应该是思考得最为频繁得两件事。考研有风险，而且对经济独立有一种向往，所以时常在想着怎么开始第一份实习；感觉自己基础还不够扎实，尚不能胜任技术含量高得工作，而且担心本科学历会成为职业生涯的瓶颈。就是一个选择题，想了一个学期也没想明白，后来就决定先实习吧，一些主意光想就如同空中楼阁，不切实际，不如职场走一圈，去体会一下本科就业是否适合自己，就这样，路是走出来的，不是想出来的，适合什么亲自体验一番就知道了。</p><p>苒苒时光，当然不乏感动与快乐。</p><p>前两天哥哥在家人群里告知今年可能赶不上年夜饭了，让我们不要等他吃饭了，我先是厌恶它们公司放假晚而后只是无可奈何，爸爸看到消息以后说了一句“不怕伐个车去高铁站接你”，而后又说“我去高铁站联系车等你”，心里是感动的感觉，父母在的地方都是家，什么都不用怕。</p><p>每个人都开始忙碌各自的事，疏远的人越来越多，能够时常问候的人越来越少。和王金梅相识快十年了，感情依旧，幸甚。</p><p>今年课外文学阅读21本，还好阅读这个习惯没有被荒废掉。《霍乱时期的爱情》这本书使我最为震撼，贯穿一生的爱情，读来让人唏嘘。</p><p>一直想学口琴的，买了一把很贵的口琴却束之高阁，三分钟热度要不得。</p><p>今年有幸出境德国游学一次，有什么收获也说不上来，对自己的影响却是有的，时常想起自己说过好好学习，积极生活，山河俊秀，不可辜负。这个世界那么美，那么多原子聚合成一个现在的我在这宇宙千万年里就那么一次，真应该珍惜短短剑，去走遍山川湖海。</p><p>对下一个十年没什么规划，继续努力吧。</p><p>2020，对我好一点。</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>真爱之上，勿问时光</title>
      <link href="/2019/11/16/%E7%9C%9F%E7%88%B1%E4%B9%8B%E4%B8%8A%EF%BC%8C%E5%8B%BF%E9%97%AE%E6%97%B6%E5%85%89/"/>
      <url>/2019/11/16/%E7%9C%9F%E7%88%B1%E4%B9%8B%E4%B8%8A%EF%BC%8C%E5%8B%BF%E9%97%AE%E6%97%B6%E5%85%89/</url>
      
        <content type="html"><![CDATA[<p>船长看了看费尔明娜·达萨，在她睫毛上看到初霜的闪光。然后，他又看了看弗洛伦蒂诺·阿里萨，看到的是他那不可战胜的决心和勇敢无畏的爱。这份迟来的顿悟吓了他一跳，原来是生命，而非死亡，才是没有止境的。</p><p>“见鬼，那您认为我们这样来来回回的究竟走到什么时候呢？”他问。</p><p>在五十三年七个月零十天以来的日日夜夜，弗洛伦蒂诺·阿里萨一直都准备好了答案。</p><p>“一生一世。”他说。</p><p>断断续续读完《霍乱时期的爱情》已经快花了两个月的时间，看着书中弗洛伦蒂诺·阿里萨和费尔明娜·达萨从青年时期的青涩爱情中走失彼此，错过一生，再到生命的最后放下世俗成见，勇敢的走到一起，既唏嘘爱情的脆弱，也震撼于爱情的坚强。</p><p>年轻时的弗洛伦蒂诺·阿里萨曾独自一人坐在花园中的一条不易被发现的长椅上，在杏树的树荫下假装读一本诗集，直到看到那位可望不可及的姑娘走过。一念既起，执念终生。</p><p>弗洛伦蒂诺·阿里萨和费尔明娜·达萨也曾在情窦初开之时互相写信，通过文字悄无声息的传递着对彼此的思念和情意。</p><p>费尔明娜·达萨的父亲希望她的女儿通过一桩美满的婚事获得新生，两个年轻人脆弱且卑微，没有站在一起对抗世俗的风雨，一个短暂的远走他乡，一个被迫与父亲远游历练，在安排之下嫁给了声名显赫的医生。</p><p>弗洛伦蒂诺·阿里萨没有放下执念，跳出时光洪流，开始一生的等待。虽然费尔明娜·达萨已为人妻，在在柴米油盐中经历着所有人都会经历的酸甜苦辣、争吵和欢笑，但是弗洛伦蒂诺·阿里萨安心的修缮好房子就，并且决心一生独身，他自然的等待，等待费尔明娜·达萨的丈夫死去，再让他有机会得到她的爱。他的心是觉得忠诚的，虽然身体曾经无数次出轨。</p><p>长达五十一年等待后费尔明娜·达萨的丈夫意外死亡，弗洛伦蒂诺·阿里萨第一时间开始了对她的最求，回忆瞬间涌来，仿佛五十余年的时光不曾流逝。这一次，费尔明娜·达萨已经不再惧怕世俗压力，她说：“一个世纪以前，人们毁掉了我和这个可怜男人的生活，因为我们太年轻；现在又想在我们身上故技重施，因为我们太老了，让他们见鬼去吧，如果说我们这些寡妇有什么优势的话，那就是再也没有人可以对我们发号施令了。”</p><p>两个人在船上度过了最快乐的时光，也许是最后的时光。</p><p>读这本书的过程中多次想起一句歌词：假如我年少有为不自卑，懂得什么是珍贵；假如我年少有为知进退，才不会让你替我受罪。经常会看到很多人遗憾在最想照顾一个人的时候没有足够的勇气和能力，等到失去之后，虽然能力已经匹配，也有了抵抗流言的勇气，却也只能是一个人独自挣扎了，爱的人早就走散了，不甘心却也再也求不得。</p><p>这样的事情几千年了一直都有，别人的故事一直在听，自己却怎么也学不会的，真正要懂的道理，只有自己亲身经历并为之付出代价才能学会的，代价越惨重，领悟越深刻，这个时候道理记住与否多半不重要了，失去了就真的失去了，有些人有些事一辈子只能有一次。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十日游学，穿越德国</title>
      <link href="/2019/08/27/%E5%8D%81%E6%97%A5%E6%B8%B8%E5%AD%A6%EF%BC%8C%E7%A9%BF%E8%B6%8A%E5%BE%B7%E5%9B%BD/"/>
      <url>/2019/08/27/%E5%8D%81%E6%97%A5%E6%B8%B8%E5%AD%A6%EF%BC%8C%E7%A9%BF%E8%B6%8A%E5%BE%B7%E5%9B%BD/</url>
      
        <content type="html"><![CDATA[<p>day  1<br>经过十六个小时的飞行，今天早上十点到达德国汉堡。从起飞时俯瞰广州夜景的兴奋，到震惊于伊斯坦布尔的繁华，到身临其境的感受汉堡怡然自得的城市生活。汉堡给我的第一印象就是这里真是一座适合养老的城市，气候适宜，环境优美，生活节奏不慌不忙。街头两侧的房子都是精心设计的艺术品，红褐色的砖，凸起的房梁，朴素自然的装修，看起来美极了，真想为每一栋房子拍一张照片。<br>可口的中国餐，参观汉堡大学，夜晚结伴逛超市，真是美好的一天，我太困了，先睡觉了。</p><p>day 2<br>吃完早餐以后向汉诺威市进发，约一个小时来到了今天的第一站SLC，这是一家仓储公司，虽然先后进行了公司介绍，实地观摩，视频讲解等环节，我对这个公司在使用IT技术使得它不同于传统仓库的地方还是没有什么概念，当然不是吴导翻译的问题，只是我觉得并没有什么特别之处。<br>在观摩结束以后两点总结我觉得很有意义，第一，企业发展不可能是一本企划书就可以一蹴而就的，需要在不断的发展中不断试错，不断改进，第二，一个人对一件事不感兴趣也可以做得好，但是如果想把一件事做到极致，却缺兴趣不可，这让我我很焦虑，计算机科学发展得如火如荼，而我真的对它感兴趣吗？外加一点思考，企业发展不是单独依靠技术人才或者财务人才或者公关人才就能发展得好的，一个企业就是一个系统，决策者在领导企业前进的时候必须综合考量，不能违背经济学总资本追逐利这一基本原则。<br>中午了一些汉堡，薯条，可乐何水果沙拉，和妈妈打电话时国内已经八点了，真想带爸爸妈妈经历一下他们觉得很新奇的事。<br>三个小时来到市政厅，德国的高速公路真慢。给王金梅寄出了一张明信片，我好希望它能收到啊 。晚餐是一顿中餐，和张伟聊得挺好。入住酒店以后逛了商场，基本上都在八点钟关门了，德国人真悠闲。</p><p>day3</p><p>今天早上都在前往柏林的路上，下午达到柏林，在WISTA听取了他们关于高新技术园区产业孵化的介绍，认为大学，研究生，工厂三个要素是产业发展的必要条件，由于有些困倦，没有记住其他要点。<br>在乘车去吃饭的路上，遇见路边有一些其他国家的难民在公路边上给人家洗车，虽然一些司机拒绝给小费或者在他们的坚持索要下才勉强给了很少的小费，但是他们的脸上仍然洋溢着乐观自信的笑容，这让我很感动。生活多舛，我们唯有乐观可以在苦难面前从容不惊。</p><p>day4<br>今天周六，是休闲的一天。先后游览了胜利柱、苏联攻占柏林纪念园、帝国大厦、五大部、总理府、勃兰登堡门、屠杀犹太人纪念园、柏林墙、洪堡大学、圣母大教堂、博物馆、马克思恩格斯纪念园。<br>在游览柏林墙的时候看到几个黑人在很惬意的享受周末，本来想拍他们，但他们不知为何非常紧张，就此作罢。<br>午餐的时候和学院副书记闲聊追求时尚，他的观点认为受过教育的人应该形成自己的品味，不能被潮流引领，否则会沦为欲望的奴隶，我很认同。<br>八点回到酒店，倒下就睡着了，凌晨十二点才醒过来。</p><p>day4<br>今天周六，是休闲的一天。先后游览了胜利柱、苏联攻占柏林纪念园、帝国大厦、五大部、总理府、勃兰登堡门、屠杀犹太人纪念园、柏林墙、洪堡大学、圣母大教堂、博物馆、马克思恩格斯纪念园。<br>在游览柏林墙的时候看到几个黑人在很惬意的享受周末，本来想拍他们，但他们不知为何非常紧张，就此作罢。<br>午餐的时候和学院副书记闲聊追求时尚，他的观点认为受过教育的人应该形成自己的品味，不能被潮流引领，否则会沦为欲望的奴隶，我很认同。<br>八点回到酒店，倒下就睡着了，凌晨十二点才醒过来。</p><p>day 5<br>今天是星期天，仍然是德国人休息的一天，。早餐以后乘车前往莱比锡，中午到达，莱比锡在历史上属于东德，东德是社会主义阵营的一部分，也可以看出来相比于资本主义阵营西德的贫穷落后。午餐完毕前往德国民族大会战纪念碑，四周景色尽收眼底。继续参观德国公墓和中央火车站，大概了解了德国的丧葬文化，对德国人热衷植树还是很佩服的，这历史久远的火车站不像火车站，里面各种商铺尽管是星期天也正在营业。逗留太长时间，没有时间参观莱比锡大学和市政厅了。</p><p>day 6<br>今天可以说一天都是在车上度过的。八点出发前往美因茨，高速公路两旁的景物已经渐渐由平原变成森林，阳哥撒在松树上的暖色让人很享受。下午三点到达美因茨大学，听了教授关于德国数字化的讲座，有幸得到一个提问机会，我问教授为什么移动支付如此方便但是德国却不使用，他的回答说银行资本家拒绝使用，这也许就是资本主义的弊端，阻碍生产力进步。讲座结束继续乘车前往美因河畔法兰克福。</p><p>day 7<br>今天从法兰克福前往斯图加特参观凯驰生产线，高速公路两旁开始出现出现山峦，平缓的山坡上星罗棋布的种了一些苹果树，大巴行驶几分钟便会出现静谧的欧洲小镇。早上十点抵达。讲座和生产线观摩，给我印象最深的就是德国中小型企业对独特品牌的执着追求，对质量的严格把关，他们始终坚持做一种产品，并把这个产品做成全行业第一。<br>中午开始下起蒙蒙细雨，来到一个奢侈品大卖场，只不过囊中羞涩，什么都没买。</p><p>day 8<br>今天一早便开车去海德堡，沿着内卡河行驶一会儿下车，跟着吴导走在欧式风格的小镇上，遥望海德堡城堡，探访海德堡大学，真是一件惬意的事情。独自爬山来到哲学家小路，据说这是康德等哲学家曾经走过的小路，这条小路上人很多，但是大家都很惬意的在散步，不慌不忙。遥望远处，红色砖瓦的欧式风格小屋连成一片，绵延到远方。下山的时候一个中国女孩请我给她拍照，我很开心，因为听到中文真的不容易。<br>午餐结束以后乘车返回斯图加特参观梅赛德斯奔驰博物馆，偶遇一个女孩，不知姓名不知国籍，就是觉得她好美，全程无心观车，要么尾随其后，要么站在她会经过的地方带她经过，可以想象喜欢一个人会有多么卑微。</p><p>day 9<br>早上从斯图加特前往辛德芬根参观梅赛德斯奔驰生产线，第一条生产线全是机械手在流水线上加工汽车，这让人很震撼，机械化程度如此之高的工厂，德国不愧是一个工业强国，中国相比之下还差得很远。第二条生产线是定制化生产线，个人都在流水线上各司其职，但是生产效率也同样很高，一天可以完成170台左右。<br>乘车前往慕尼黑的路上，猪排和炸土豆作为简单的午餐，下午四点到达慕尼黑，两个小时的购物时间，强哥，家源和我还是一样都没有买，我手机没电独自去找洗手间，资本主义太可怕了，地铁站里的洗手间都要收费，无奈没带钱，只能忍着了。闲逛之余，看到街头忘我的弹钢琴的男子，夕阳撒在教堂的余晖，一切都那么赏心悦目，很开心一个中国同胞和我打招呼。<br>今天晚上的晚餐比较特别，到德国皇家啤酒屋就餐，9欧元的半杯啤酒喝得我心痛，这里挤满了人，大家啤酒和猪脚吃得很开心，加上愉快的音乐，真是一个美好的晚上。</p><p>day 10<br>今天是在德国的最后一天，原定计划参访慕尼黑工业大学，与留学生联谊的活动莫名其妙就没有了，早上起来直接前往市中心自由活动，我选择临走之前给家人买一点礼物。<br>逛了许久给弟弟买了一块手表，给爸爸买了一个钱包，由于时间不够，也是不了解妈妈和哥哥的喜好，没有给他们买，很遗憾。两件礼物折算人民币挺贵的，但是难得来一次，就狠心买了，以后努力挣钱吧。<br>六点半起飞，九点抵达土耳其的伊斯坦布尔，本来凌晨一点的飞机居然延误到五点，太难了。</p>]]></content>
      
      
      <categories>
          
          <category> 人生履历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见，盘联，年岁中最灿烂的一段时光</title>
      <link href="/2019/08/06/%E5%86%8D%E8%A7%81%EF%BC%8C%E7%9B%98%E8%81%94%EF%BC%8C%E5%B9%B4%E5%B2%81%E4%B8%AD%E6%9C%80%E7%81%BF%E7%83%82%E7%9A%84%E4%B8%80%E6%AE%B5%E6%97%B6%E5%85%89/"/>
      <url>/2019/08/06/%E5%86%8D%E8%A7%81%EF%BC%8C%E7%9B%98%E8%81%94%EF%BC%8C%E5%B9%B4%E5%B2%81%E4%B8%AD%E6%9C%80%E7%81%BF%E7%83%82%E7%9A%84%E4%B8%80%E6%AE%B5%E6%97%B6%E5%85%89/</url>
      
        <content type="html"><![CDATA[<p>2019年寒假，还在火车上就已经一直看着窗外的风景，裸露的山丘和成片的油菜花不断消失在身后，火车不断前进，我的心却好像比火车还要快，早已经到达盘联寒假工作的集合地点——盘州市职业技术学校。下午五点左右火车终于抵达，盘州冬日的暖阳配上短袖刚刚好，急忙叫了一个摩的就直接到职校报到。来到职校见到了以前的老友，当然也有新人。</p><p>这个假期我同时负责企业观摩会、全国分会、媒体中心。想想已经是在盘联的第三个假期了，比自己老的人已经没几个了，自己真的做好准备去做一个独立的负责人了吗？好像没有，自己并没有成熟多少。</p><p>小汪老大，阿绿和我，我们三个搭档负责媒体中心一直让我充满信心，小汪细心可靠，阿绿技术过硬，在校期间一起沟通媒体中心日常工作、周末专栏约稿、组织招新、宣传盘联等等，三小只这个群成为使用频率最高的群这一，和你们一起商量做事真好。</p><p>今年媒体中心又注入了新鲜的血液，刚哥、亚南、章金、永浩、明丽、红霞。在校还没见面时就约定面基的时候谁如果认不出对方就请吃洋芋吧，虽然开过视频，但是还是出现没有认出来的情况。小汪一开始没认出刚哥，我也没认出一直跟在小汪后面的亚南。媒体中心是一个大家庭，拍一张全家福实在不容易，在办完企业人才沙龙以后，大家一起到东湖拍合照，已经是日落了，等大家聚齐拍完合照感觉天瞬间就黑了。</p><p>绝大多数的盘联记忆都来自于媒体中心，一起围坐桌前编辑推松、排版杂志，一起配置路由器、一起吃饭、一起翻铁门吃早餐、一起踏着夜色高唱《放飞》走回宿舍……</p><p>拍完合照以后新老成员聚餐，结束以后想去KTV唱歌，但是今天企业人才沙龙的推松好像还没有排，小汪老大，刚哥和我就近找了一家网吧去做推松。小汪老大一看就是惯犯，心平气和走完全程，我就比较垃圾了，参会名单没有，推松也做不成。</p><p>唱完个大家也还不甘心就散掉，那就再去吃烧烤吧，吃烧烤当然不可能就只吃烧烤，那么多人得吃多少钱呀？喝酒才是真的。曦姐，沙沙和我一起提了两件啤酒，配上烧烤，烟火味十足得开始划拳喝酒。酒过三寻，还剩几瓶没喝完，职校是回不去了，那就鑫盛宾馆开一个套间回去继续喝。小汪阿绿状态都还好，其他要么醉意朦胧要么睡意朦胧。这个时候都是最无顾及得状态，和小汪直接拿起瓶子干的样子真是痛快。渐渐大家都睡去，第二天当然是难受的一天，但我好像神清气爽的过了情人节。媒体中心彻夜长谈还有一次，文艺汇演结束当晚，沙沙和娜姐在宿舍等我们，尽管我们排完推松回到宿舍已经很晚了，她们还是等着。天南海北忘记说了些什么，但年轻人在一起谈的感情问题通常不会缺席，媒体中心如何继续发展也讨论了好久。</p><p>这个寒假盘联已经走过14年的风雨了，从最初的“前程”演讲会，到今天制度齐全发展成熟的盘州市大学生联谊会，很多人在这里投入了很多心力也收获了成长，很幸运，我是其中的一位。在一起为盘联庆祝生日的时候真的很感动，一起高唱会歌，一起吃一块蛋糕，一起说出对盘联的祝福，一起陪盘联继续走下去。</p><p>这个假期我把主要精力都投入到了企业观摩会这个活动中，从负责人选举时的一时兴起，到彻底结束这个活动竟前好将近花费了近一年的时间。从反复修改策划，到开始联系企业，经历了在一家公司门口无聊的等待、经历了在出发产研中心之前还没有车的恐慌、经历了被企业对接的工作人员忽视的难受、经历了昆明城区限高导致活动延期的急躁、经历了八点从红果打车回家被司机带到丹霞的荒诞、经历了4000块车费迟迟不到账的烦恼……</p><p>对于全国分会，我的工作始终是不到位，因为我最初就不知道什么是全国分会，然后到后来的觉得全国分会没有多少实际意义，每次思考该怎么去改进它的时候，最好的思考结果都是再问自己全国分会现在真的还有意义吗？鹏哥和丹卿姐在上面投入了许多精力，翱翔和我在迷茫中接过担子，发现有点被动的去做一件事，分会活动越来越少，一些分会甚至成员都补齐，应付着主席团下达的任务，对于这些情况，感觉有点无力。</p><p>第七次会员代表大会选举出了新一届会长团，那天情绪有些低落，我想大概来自于新旧交替的自信心缺乏和出乎意料的选举结果。小汪当天回家，部门好像没剩下几个人在位了，加重了这种情绪。</p><p>在学校协助完成了职中杂志的排版，现在算是从盘联的工作中抽身出来了吧，但还是很关注朋友们在盘联工作的新闻，有时真的很向往那种在一起做事的快乐。</p><p>再见，盘联，年岁中最灿烂的一段时光。</p>]]></content>
      
      
      <categories>
          
          <category> 人生履历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 盘联 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盘联时光，渐入佳境</title>
      <link href="/2019/07/31/%E7%9B%98%E8%81%94%E6%97%B6%E5%85%89%EF%BC%8C%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83/"/>
      <url>/2019/07/31/%E7%9B%98%E8%81%94%E6%97%B6%E5%85%89%EF%BC%8C%E6%B8%90%E5%85%A5%E4%BD%B3%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>还记得在刚刚面试加入媒体中心的时候我曾问娜姐，盘联的小伙伴之间关系真的那么好吗？他很确定的告诉我是的。2018年暑假回家，迫不及待的想再见到那群上个寒假在一起工作的人。刚刚下火车，就先赶到鑫盛宾馆，但由于还要回家，只在楼下见了敖倩和杨佐。</p><p>这个暑假娜姐实习没有回来，是沙沙主要负责媒体中心。大家集结都比较快，阿绿，小汪，菜玲，丹丹，小甘，沙沙，敖倩，杨佐，阿曦，翱翔，还有我，都迅速在在鑫盛宾馆五楼的一个小房间里集合。小甘到位那一天中午正好是老成员丽平姐和陈曦来请吃饭，很多人都是初次见面，却真的感觉就像早就认识了一样。</p><p>办公场地比较紧张，和宣传部挤在一个套间里面，里面就是三间客房一个卫生间一个洗漱间，而我们整个部门就围绕在一张茶几周围，插座和桌面的利用率接近百分之八十。七八个人围坐在这里，阿绿踏踏实实的完成了表情包设计，丹丹在新闻稿上独当一面，倩倩、翱翔、阿曦紧锣密鼓的筹备盘联直播，小甘直接上手剪辑视频，杨佐时常提出很多建设性意见，菜玲和小汪杂志排版全面推荐，沙沙统筹全局，有条不紊，我，十多天一个百度百科也没修改好。媒体中心经常熬夜这是真的，我总感觉就是才上班一会儿怎么就又要下班了。两次熬夜记忆深刻，一次是工作到很晚了，大家开始谈心，睡衣全无，都互相指出最近存在的问题和小伙伴们需要改进的地方，凌晨三点才睡；另一次是校对汇报杂志《盘联之声》，一字一句，标点符号也不容出错，后来再看其他媒体的推松或者文章，总是偶尔去纠一下别人的排版或者句子的错误，我很确定，这是再媒体中心呆久了落下的病根。</p><p>在一起做喜欢的事情是一件很开心的事，然而我们这群俗人当然也想着安排一下，因为在红果大城花天酒地是一件很美滋滋的事呀。总是想着哪天安排一顿烤鱼，哪天去KTV嗨一晚，哪天去吃一顿烧烤。我很抱歉呀，一开始答应翱翔和阿绿我要安排一次烤鱼的，结果食言了，但是难忘的事情总是出于意外，下班以后不甘心就这样睡去，对后勤安全部含糊其辞的报备以后，走上弥漫啤酒与烤串味的红果街头，想着在哪家小店一醉方休。最后来到只放了桌子板凳的一家临时小店，点上啤酒烤串，当然都不会落下真心话大冒险之类的游戏。</p><p>吃喝玩乐的时光总不会少，联谊会全体小伙伴在东湖边上的联谊很有趣，虽然很多人是初次见面，很多人平时很内向，但大家也都放开了玩。至于我们部门，总是喜欢烧烤店和KTV这种喧闹的地方，大声打牌、大声（跑调）唱歌总是让人很放松。</p><p>我很多次都潜意识的认为我们部门是盘联最优秀的部门，我想这种错觉来源于我们都很团结。在每一场活动到来之前，只要需要我们，拍照、写稿、推送制作、音频视频设备控制总是各就各位，有条不紊，比如吃盒饭也有爱的围在一起。</p><p>又是一个躁动不安的晚上，大家又厮混到了红果街头，不过这次意见不是很统一，看电影不成，吃烤鱼时机不合适，当时又要下雨了，往回走的时候实在不甘心就这样回去，居然进了凯歌KTV打算唱歌，一问价格有点贵，悻悻离去，出来才觉得尴尬，太丢联谊会的人了吧，都快十二点了穿着联谊会的文化衫在街头游荡也就算了，在这个点了居然还打算一头钻进KTV。只有在KTV里面才知道谁是麦霸，我觉得翱翔都比不过阿绿。</p><p>联谊活动那天的游戏我觉得好像很一般，但是人多了玩起来就很有趣，背对背带气球？其他好像记不起来了叫什么了。六月的雨打断了活动，但是意外的美丽总是难忘，所以才会有接下来的在避雨的时候，悠闲的喝着刺梨王，合唱会歌《放飞》，我们的歌声在东湖公园回荡了很久，阴沉的天气也阻挡不了我们的欢快。</p><p>每天一起结伴去吃饭也是一件很开心的事，要走十分钟吧，不过那家饭店真的好小，菜也做得不怎么样，偶尔几次都是最后没菜只能吃米饭。经验证明，挤在一起吃饭可以助长胃口，所以总是感觉一直在加菜，渐渐的明白还是多吃米饭吧，文气一点。</p><p>住宿，就是回住处晚了的会没地方睡，一开始支教活动队员还没来报道还好，挤一挤还是睡得下去的，然而随着队员增多，问题来了，没地方睡。一次我回房间晚了，只能翻窗子去另一个房间睡沙发，其实有沙发也还算好，有一次连沙发也没了，阿绿拿一块沙发坐垫直接睡地上，他为人比较好，让我睡了沙发。</p><p>暑假活动要结束了，大学生论坛拍照、各种活动启动仪式、大小会议、企业人才沙龙、全国分会代表大会，都有在参与，却感觉没做什么，接下来也未多做考虑，接下协助市团委文化督察的任务，五天走访普古、羊场、鸡场坪、淤泥河、旧营、英武。真的多亏了徐康、徐赛、徐矿和许娟的全程陪伴，在这场渐渐枯燥的下乡活动中始终充满乐趣，爬过娘娘山，体验了一次一览众山小的感觉，也第一次在鸡场坪的酒店里尝试了红酒的滋味，第一次去小康家玩得那么开心。</p><p>在工作基本都结束以后，抱着游玩和帮助菜玲小甘完成剩余检查任务的心态，我和阿绿也来到了竹海。没走过多少竹海的路，但我觉得竹海景色真不怎么样。小甘做东，好好的接待了我们，我一时忘乎所以，喝了个酩酊大醉，吐得天昏地暗。工作热情已经耗尽，和阿绿、聂祥娇草草结束了老厂的检查，就赶回盘县了。</p><p>这是一个热情洋溢的暑假。</p>]]></content>
      
      
      <categories>
          
          <category> 人生履历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 盘联 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于盘联，情不知所起，一往而深</title>
      <link href="/2019/07/30/%E5%AF%B9%E4%BA%8E%E7%9B%98%E8%81%94%EF%BC%8C%E6%83%85%E4%B8%8D%E7%9F%A5%E6%89%80%E8%B5%B7%EF%BC%8C%E4%B8%80%E5%BE%80%E8%80%8C%E6%B7%B1/"/>
      <url>/2019/07/30/%E5%AF%B9%E4%BA%8E%E7%9B%98%E8%81%94%EF%BC%8C%E6%83%85%E4%B8%8D%E7%9F%A5%E6%89%80%E8%B5%B7%EF%BC%8C%E4%B8%80%E5%BE%80%E8%80%8C%E6%B7%B1/</url>
      
        <content type="html"><![CDATA[<p>现在是晚上十一点半了，终于将追忆盘联这件事付诸行动了。以前还在盘联负责一些工作的时候就有过这个想法了，想着等哪天我结束了在盘联的工作了，一定要花时间把这段让我全力以赴投入其中的经历记录下来，因为在这里遇见了那么多志同道合的、有趣的、朴实的伙伴，因为在这里从对学生组织的一无所知到独立组织活动，因为在这里我看到了自己的成长。</p><p>遇见盘联从参加还未成型的企业观摩会开始，刚刚考上大学就收到盘联邀请参加兴仁泛亚集团，见到了元元姐、波哥、丽萍姐。白天参加活动一天但是人都没记全，晚上泡温泉才嗨到一起。短暂的一天观摩活动结束，但是我们的缘分还要继续。</p><p>2017年10月，盘联招新，报名媒体中心。据娜姐们后来说，他们在讨论是否接收我的时候，他们争议很大。寒假集合，很忐忑的来到职校，迟到的我见到了第一个我在加入盘联后遇到的人，张彦飞。进入集合教室时原来他们在开见面会，不明情况的我赶紧走到一排坐下，林广和龙哥，汤坤贤唱歌的情景都还清晰。</p><p>寒假，天气比较冷。第一晚睡觉就成了问题，职校的床太短了，被子不但薄还短，睡觉一直时一件很困难的事，头几天都是睡到半夜被冷醒，实在受不了，拼床。管鸿盛，习权州和我，三个人睡两张床，挤在一起舒服多了。热水供应也是固定时间的，想洗头什么的请早起。有一天早上去吃早餐的一段上坡的沥青路结冰了，我们三个互相扶着也站不稳，只能走路边的水沟上去。那是晚上十点左右吧大家一起回宿舍，虽然冷但是大家在一起很开心呀，路边还有小伙伴互相打雪仗，在上一段台阶的时候，一个女生没站稳，左右摇摆了3秒吧，还是摔倒了，对不起我当时笑出了声。</p><p>说真的，在盘联的这个假期，在技能方面，我是真的是一块朽木，简单的PS，ID也是总学不会，问对面宣传部的龙哥问得太多了我都不好意思了，比如说，至今也没搞懂什么是蒙版。十多天在办公室我就排了几页ID？是这样吗？好像是。娜姐让我把我的作品发给姜鹤看一下，当时的我居然自信满满的说还可以，她们却觉得太中规中矩了，审美需要提高。工作的东西记不太多了，因为我感觉这个寒假我就是被保护的小朋友，媒体中心六个老成员我一个新成员，美滋滋的，工作完全没有压力。</p><p>一个地上堆了一层小雪的早晨，大家专门抽出时间拍合照。媒体中心和宣传部由于姻亲关系等原因，关系比较好，所以一起拍，撒雪拍照很浪漫呀，定格了很多美好的瞬间。</p><p>后来陈曦要走了，没有过多的不舍得，只是感觉那两天媒体中心好像突然散掉了，对的，就是这种感觉，因为大家都不怎么说话了，迟到早退也出现了。送陈曦离开是一个晚上，也是十点左右吧，本来只是娜姐和沙沙去送，后来我和廷哥也跟了下来。世间难忘的事多半是因为巧合，比如这一次五个人的彻夜畅谈。走到大桥上俯瞰红果城，瞬间脚步轻快了许多，所以一下子就从干沟桥游逛到了红果街头，也许也是因为和三五好友畅谈惬意的缘故。还不想散，那就干脆在鑫盛开一个套间不回宿舍了吧，扎完气球又在去卖烧烤回来吃，聊天到什么时候也忘记了。</p><p>喝酒的时光最让人难忘，即便当时连路都走不稳了，过后却记得明明白白。寒假工作结束，大家回家之前本来小聚一次，但不知道怎么就聚到烧烤店里面去了，朱怡，龙哥，陈曦，娜姐（不胜酒力），沙沙（撂倒一桌猛汉），张昭海喝了几场以后，沙沙又叫来几个朋友，继续下半场，跑洗手间越发勤快了。记得当时江小白酒瓶上写了一句话——青春不是一段时光，而是一群人。</p><p>二分之一财务部的蝶姐，头顶戴一口锅的花儿，很搞笑的三瓢，很多未及深交的小伙伴，明年暑假见。</p>]]></content>
      
      
      <categories>
          
          <category> 人生履历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 盘联 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/29/hello-world/"/>
      <url>/2019/07/29/hello-world/</url>
      
        <content type="html"><![CDATA[<br><p>花了两天的时间，终于把博客搭好了，以后要多写东西呀。</p>]]></content>
      
      
      <categories>
          
          <category> 实践心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在五月初五</title>
      <link href="/2019/07/28/%E5%86%99%E5%9C%A8%E4%BA%94%E6%9C%88%E5%88%9D%E4%BA%94/"/>
      <url>/2019/07/28/%E5%86%99%E5%9C%A8%E4%BA%94%E6%9C%88%E5%88%9D%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<p>在2019年2月9日星期六写下这篇文章有点尴尬，要怎么样来定位它呢，算是对去年的总结吧，有一点晚了，如果说是今年的展望吧，也有一点晚了。那就把它写成对2018年的回忆吧。</p><p>年初继续参加了联谊会的年后工作，作为小朋友，感觉什么都没有做，也没有学到什么东西，就匆匆混过了年后十天。</p><p>大一的下半个学期仍然没有感觉到学业的压力，仍然坚持读万卷书行万里路的生活理想。</p><p>读完了林语堂的《苏东坡传》、路遥的《人生》、余秋雨的《行者无疆》、姚云的《坐到夕阳披挂下来》、阮义忠的《失落的优雅》、宿文渊的《人一生要注意的50个细节》、安武信吾的《会做饭的孩子走到哪里都能活下去》、阿科塞的非常病人：《病夫治国》续集、洪应明的《菜根谭》、中华人民共和国宪法、叶子的《北京没有海》、毛泽东的《矛盾论》和《实践论》、杨伯钧的《论语注释》、当年明月的《明朝那些事儿》前七部等。</p><p>去越秀区看了花灯，回来的路上即兴去了了天河区；历经挫折找到了向往已久的大夫山，却感觉风景一般；火炉山除了大也有没有什么特别的风景；华南农业大学还好，除了景色不错，还有独家的华农酸奶，这里也要感谢老同学刘萍的接待；某天下午参观了广州市图书馆和广东省博物馆，这一张图让我驻足许久；借作为志愿者的身份，免费玩了一次忘记叫什么的馆；在国庆节去了石室圣心大教堂，感受了一下基督文化，广州十三行博物馆让历史书上的东西再现眼前；沙面大街建筑独特，这应该是是带女朋友去的绝佳去处，一直想乘坐邮轮看一下夜色中的广州，那一晚也得偿所愿；华南植物院与中大有着很深的历史渊源，班级团日活动参观了这里；在元旦节，一次性玩了红专厂创意园、广州动物园等，第一次见到了很多动物；去深圳参观了华为总部，第一次让我清醒的知道为什么要到大公司就业。</p><p>上半学期虽然感觉自己很努力了，但是排名仍然不够理想，就好像忙碌是为了麻痹自己一样。3.008的绩点已经到了本专业的末尾了，直接导致选择专业方向时被调剂到了超级计算机方向。六月初，一个已经快被遗忘的女孩闯入我的世界。</p><p>很快又到了暑假，这暑假的几乎全部时光都是在盘联度过的。成为了媒体中心的副主任，但是什么都不会的自己什么都做不好，唯一的任务修复百度百科也没有完成。倒是在带队下乡验收创文工作时经历颇多，感悟颇多。</p><p>回到学校决定报名学车，由于课业繁重，考过科目一就没有时间练习剩下的科目了。</p><p>我是很矫情的，莫名其妙的回到了了一个人的状态。这样也适合我，有空了就去摸索学习建设网站、做小程序、做app，学Linux，但是什么都没有学好。叫上两个朋友，组了三剑客小队参加学校ACM新手赛，侥幸获奖；满腔热血的又带头组队参加中国大学生服务外包大赛，感觉什么都不会居然选择了题目“智慧教室学生状态检测系统“，不想放弃和无从下手的状态困扰我许久，最后只能选择放弃，愧对四位同学。公教楼，图书馆、食堂、宿舍，四点一线的度过了大二下学期。</p><p>寒假直接去了职校，这一次我扮演的角色是媒体中心副主任、企业观摩会负责人、PBC执行副主席。第一次组织企业观摩活动，带领22个人去了宏财集团参研中心和金彩盘州旅游集散中心，由于自己经验不足和一些客观原因，效果不理想；参与筹备PBC第四次全国代表大会，也出现许多纰漏；媒体中心寒假工作繁重，说起来就只有愧疚。</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心情 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
